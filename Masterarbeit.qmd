---
title: "Masterarbeit"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-depth: 4
    toc-float: true
editor: visual
---

## Load necessary libraries
```{r}
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)
library(knitr)
library(stringr)
```
## Data Reading
**Description:** Define directory and combine single data files into one dataset
```{r}
# Define the directory containing the files
data_directory <- "/Users/linabecker/Documents/M.Sc. Health Science/Masterarbeit/Masterarbeit/Datensätze"

# List all CSV files in the directory
file_list <- list.files(path = data_directory, pattern = "*.csv", full.names = TRUE)

# Initialize an empty list to store individual data frames
data_list <- list()

# Loop over each file to read, process, and add to data_list
for (file in file_list) {
  # Extract the ID from the filename
  id <- sub("_.*", "", basename(file))
  
  # Read the file, skipping the first row and using the second row as the header
  df <- read.csv(file, skip = 1, header = TRUE)
  
  # Add the ID column
  df$ID <- id
  
  # Append the processed data frame to the list
  data_list[[length(data_list) + 1]] <- df
}

# Combine all individual data frames into one
combined_data <- bind_rows(data_list)

# View the combined data 
head(combined_data)

# Get a summary of unique IDs
id_summary <- combined_data %>%
  distinct(ID) %>%
  count()

# Display the summary
id_summary

# Convert ID to a factor
combined_data <- combined_data %>%
  mutate(ID = as.factor(ID))

# Rename the columns
combined_data <- combined_data %>%
  rename(
    DeviceTimestamp = Device.Timestamp,
    `Glucose levels (mg/dl)` = Historic.Glucose.mg.dL,
    `Scan glucose levels (mg/dl)` = Scan.Glucose.mg.dL
  )



# View the updated column names (optional)
colnames(combined_data)

# Convert the Timestamp column to POSIXct format
combined_data$Timestamp <- as.POSIXct(combined_data$DeviceTimestamp, format = "%d-%m-%Y %H:%M")

# Verify the structure to confirm the change
str(combined_data$Timestamp)

# Reorder columns, placing Timestamp as the fourth column
combined_data <- combined_data %>%
  select(1:3, Timestamp, everything())%>%
  arrange(Timestamp)

#Check all values of Record Types

summary(combined_data$Record.Type)
table(combined_data$Record.Type)

# Process the data as specified
combined_data <- combined_data %>%
  # Remove rows where Record.Type is 5 or 6
  filter(!(Record.Type %in% c(5, 6))) %>%
  # Create a new column 'Glucose level'
  mutate(
    "Glucose (mg/dl)" = if_else(
      !is.na(`Glucose levels (mg/dl)`), 
      `Glucose levels (mg/dl)`, 
      `Scan glucose levels (mg/dl)`
    )
  )

# View the first few rows to verify
head(combined_data)
```
**Description:** Remove "Ecosleep" from ID names
```{r}
combined_data <- combined_data %>%
  mutate(ID = str_remove(ID, regex("Ecosleep$", ignore_case = TRUE )))
```

**Description:** Get an overview of distribution of historic and scanned glucose data
```{r}
# Filter out rows where both glucose values are missing
glucose_data <- combined_data %>%
  filter(!is.na(`Glucose levels (mg/dl)`) | !is.na(`Scan glucose levels (mg/dl)`))

# Plot all participants in one faceted plot
ggplot(glucose_data, aes(x = Timestamp)) +
  geom_point(aes(y = `Glucose levels (mg/dl)`), color = "blue", size = 0.1, alpha = 0.7) +
  geom_point(aes(y = `Scan glucose levels (mg/dl)`), color = "red", size = 0.1, alpha = 0.9) +
  facet_wrap(~ ID) +  # One plot per ID
  labs(
    title = "Glucose Measurements Over Time by Participant",
    subtitle = "Blue = Historic Glucose (5 min), Red = Scan Glucose (manual scan)",
    x = "Time",
    y = "Glucose Level (mg/dL)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
    strip.text = element_text(face = "bold", size = 8),
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 10)
  )
```
## Data Cleaning

**Description:** filter out all columns not needed and filter out all glucose levels, which are not historic glucose levels (which are scan glucose levels)



```{r}
# Filter out rows with NA or infinite values in Timestamp and Glucose levels columns
cleaned_data <- combined_data %>%
  filter(!is.na(Timestamp), !is.na(`Glucose levels (mg/dl)`), is.finite(`Glucose levels (mg/dl)`))

head(cleaned_data)
```

```{r}
cleaned_data <- cleaned_data %>%
  select(-Rapid.Acting.Insulin..units., -Ketone.mmol.L, -Non.numeric.Rapid.Acting.Insulin, -Non.numeric.Food, -Carbohydrates..grams.,-Carbohydrates..servings., -Non.numeric.Long.Acting.Insulin, -Long.Acting.Insulin.Value..units., -Notes, -Strip.Glucose.mg.dL, -Meal.Insulin..units., -Correction.Insulin..units., -User.Change.Insulin..units.)
```
### Missings
**Description:** check if there are missings in glucose values

```{r}
# Add a column to indicate missing or non-finite values in Glucose (1 = Missing/Non-finite, 0 = Present)
cleaned_data <- cleaned_data %>%
  mutate(
    Missing = ifelse(is.na(`Glucose (mg/dl)`) | !is.finite(`Glucose (mg/dl)`), 1, 0)
  )

# Check how many columns have the value 1 in Missings
sum(cleaned_data$Missing == 1)

```

**Description**: Create a table showing an overview of expected number versus real number of measurements per ID per Month

```{r}
# Step 1: Determine the start date for each ID (earliest timestamp)
id_start_dates <- cleaned_data %>%
  group_by(ID) %>%
  summarise(Start_Date = min(Timestamp, na.rm = TRUE) , .groups = "drop")

# Step 2: Join the start date back to the main data and filter to include only records from the start date onward
cleaned_data_filtered <- cleaned_data %>%
  left_join(id_start_dates, by = "ID") %>%
  filter(Timestamp >= Start_Date | is.na(Timestamp))  # Include rows where Timestamp is NA as well
```
**Description**: Table with overview
```{r}
# Add Month and Year
glucose_monthly_summary <- cleaned_data %>%
  mutate(
    Month = floor_date(Timestamp, "month")
  ) %>%
  group_by(ID, Month) %>%
  summarise(
    Measured_Values = n(),  # Measured Values
    Days_Observed = n_distinct(as.Date(Timestamp)),  # Observed Days per Month
    Expected_Values = Days_Observed * 288,  # Expected: 288 per Day
    Missing_Values = Expected_Values - Measured_Values,
    Missing_Percentage = round((Missing_Values / Expected_Values) * 100, 2),
    .groups = "drop"
  )

# Show Data Set
glucose_monthly_summary
```

**Description**: Add months to table when no measurement took place
```{r}

# Schritt 1: Monat berechnen
data_with_month <- cleaned_data %>%
  mutate(
    Month = floor_date(Timestamp, "month")
  )

# Schritt 2: Erster Monat pro ID
first_months <- data_with_month %>%
  group_by(ID) %>%
  summarise(First_Month = min(Month), .groups = "drop")

# Schritt 3: Vollständigen Monatsraster erzeugen (13 Monate ab Start)
full_months_per_id <- first_months %>%
  rowwise() %>%
  mutate(
    Month = list(seq(First_Month, by = "1 month", length.out = 13))
  ) %>%
  unnest(Month) %>%
  ungroup()

# Schritt 4: Tatsächlich gemessene Werte zählen pro ID und Monat
monthly_counts <- data_with_month %>%
  group_by(ID, Month) %>%
  summarise(
    Measured_Values = n(),
    Days_Observed = n_distinct(as.Date(Timestamp)),
    .groups = "drop"
  )

# Schritt 5: Join mit vollständigem Raster + fehlende Werte auffüllen
monthly_summary <- full_months_per_id %>%
  left_join(monthly_counts, by = c("ID", "Month")) %>%
  mutate(
    Measured_Values = replace_na(Measured_Values, 0),
    Days_Observed = replace_na(Days_Observed, 0),
    
    Expected_Values = days_in_month(Month) * 24 * 12,  # 12 Messungen pro Stunde bei 5-minütiger Frequenz

    Missing_Values = Expected_Values - Measured_Values,
    Missing_Percentage = ifelse(Expected_Values == 0, NA, round((Missing_Values / Expected_Values) * 100, 2))
  )


```
**Description**: Duplicates were found, because Missings were minus --> remove duplicates using cleaned_data_filtered

```{r}
#check for duplicates first
cleaned_data_filtered %>%
  group_by(ID, Timestamp) %>%
  filter(n() > 1)
```

### Duplicates

**Description**: Check for duplicates
```{r}
# All Duplicates
dup_timestamps <- cleaned_data_filtered %>%
  group_by(ID, Timestamp) %>%
  filter(n() > 1) %>%
  arrange(ID, Timestamp)

```

#### Identical/exact duplicates
```{r}
exact_duplicates <- dup_timestamps %>%
  group_by(ID, Timestamp, `Glucose (mg/dl)`, Serial.Number) %>%
  filter(n() > 1) %>%
  ungroup()

exact_duplicates
```

#### Duplicates with same Serial.Number but different glucose value

```{r}
conflicting_duplicates <- dup_timestamps %>%
  group_by(ID, Timestamp, Serial.Number) %>%
  filter(n_distinct(`Glucose (mg/dl)`) > 1) %>%
  ungroup()

conflict_summary <- conflicting_duplicates %>%
  count(ID, name = "Conflicting_Measurements")

conflict_summary
```

**Description:** Plotting those conflicting duplicates
```{r}
# 1. laufende Nummerierung erstellen
conflicting_duplicates <- conflicting_duplicates %>%
  group_by(ID, Timestamp, Serial.Number) %>%
  filter(n_distinct(`Glucose (mg/dl)`) > 1) %>%
  mutate(Glucose_Row = row_number()) %>%
  ungroup()

# 2. In Wide-Format bringen (zwei Glucose-Werte nebeneinander)
conflicts_wide <- conflicting_duplicates %>%
  select(ID, Timestamp, Serial.Number, `Glucose (mg/dl)`, Glucose_Row) %>%
  pivot_wider(
    names_from = Glucose_Row,
    values_from = `Glucose (mg/dl)`,
    names_prefix = "Glucose_"
  ) %>%
  filter(!is.na(Glucose_1) & !is.na(Glucose_2))

# 3. Scatterplot: Glucose_1 vs Glucose_2


ggplot(conflicts_wide, aes(x = Glucose_1, y = Glucose_2, color = ID)) +
  geom_point(alpha = 0.7) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(
    title = "Comparison of glucose values in conflicting duplicates \n(same timestamp, same serialnumber)",
    x = "Glucose Value 1",
    y = "Glucose Value 2",
    color = "ID"
  ) +
  theme_minimal()
```

**Description:** Checking differences of duplicates
```{r}
conflicts_wide <- conflicts_wide %>%
  mutate(duplicate_difference = Glucose_2 - Glucose_1)

  ggplot(conflicts_wide, aes(x = duplicate_difference, fill = ID)) +
    geom_histogram(binwidth = 1, alpha = 0.6, position = "identity") +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray") +
    labs(
      title = "Differences between Glucose Values",
      x = "Difference: Glucose (mg/dl)",
      y = "Number",
      fill = "ID"
    ) +
    theme_minimal()
```  

#### Duplicates with different Serial.Number but same glucose value
```{r}
duplicates_diff_serial <- dup_timestamps %>%
  group_by(ID, Timestamp, `Glucose (mg/dl)`) %>%
  filter(n_distinct(Serial.Number) > 1) %>%
  ungroup()

summary_diff_serial <- duplicates_diff_serial %>%
  count(ID, name = "Same_Glucose_Diff_Serial_Count")

summary_diff_serial
```

### Irregular Timestamps: Less than 4min, more than 6min

**Description**: Calculate timegaps

```{r}
time_gaps <- cleaned_data_filtered %>%
  arrange(ID, Timestamp) %>%
  group_by(ID) %>%
  mutate(
    Time_Diff_Minutes = as.numeric(difftime(Timestamp, lag(Timestamp), units = "mins"))
  ) %>%
  ungroup()

time_gaps
```

#### Gaps: more than 6min

```{r}
gaps_over_6min <- time_gaps %>%
  filter(!is.na(Time_Diff_Minutes) & Time_Diff_Minutes > 6)

gaps_over_6min

summary_over_6min <- gaps_over_6min %>%
  count (ID, name = "Gaps_More_Than_6min")

summary_over_6min_detail <- gaps_over_6min %>%
  group_by(ID, Time_Diff_Minutes) %>%
  summarise(
    Count = n(),
    .groups = "drop"
  ) %>%
  arrange(ID, Time_Diff_Minutes)
```

#### Gaps: between 1 and 3min
```{r}
gaps_1_to_3_min <- time_gaps %>%
  filter(!is.na(Time_Diff_Minutes) & Time_Diff_Minutes >= 1 & Time_Diff_Minutes <= 3)

summary_1_to_3_min <- gaps_1_to_3_min %>%
  count(ID, name = "Gaps_Between_1_and_3min")
```
**Description**: Categorize time gaps
```{r}
time_gaps_plot <- time_gaps %>%
  mutate(
    Gap_Category = case_when(
      is.na(Time_Diff_Minutes) ~ NA_character_,
      Time_Diff_Minutes >= 1 & Time_Diff_Minutes <= 3 ~ "Between 1 and 3",
      Time_Diff_Minutes > 6 ~ "Over 6 min",
      Time_Diff_Minutes == 0 ~ "Duplicate",
      TRUE ~ "Normal (4-6 min)"
    )
  )
```
#### Plotting those timegaps
```{r}
ggplot(time_gaps_plot, aes(x = Timestamp)) +
  # Normal (4–6 Minutes) – as Background
  geom_point(
    data = subset(time_gaps_plot, Gap_Category == "Normal (4-6 min)"),
    aes(y = Time_Diff_Minutes),
    color = "gray70", alpha = 0.5, size = 1.5
  ) +
  
  # Gaps > 6 Minutes – red
  geom_point(
    data = subset(time_gaps_plot, Gap_Category == "Over 6 min"),
    aes(y = Time_Diff_Minutes),
    color = "red3", alpha = 0.8, size = 1.5
  ) +
  
  # Gaps 1–3 Minutes – green
  geom_point(
    data = subset(time_gaps_plot, Gap_Category == "Between 1 and 3"),
    aes(y = Time_Diff_Minutes),
    color = "green3", alpha = 0.8, size = 1.5
  ) +
  
  labs(
    title = "Time Intervals Between Timestamps per ID",
    subtitle = "red = >6min, green = 1–3min, grey = 4–6min",
    x = "Time",
    y = "Time Interval Between Timestamps (min)"
  ) +
  facet_wrap(~ ID) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  )
```
### Serial Numbers

**Description**: Check how many serial numbers per ID
```{r}
serial_number_summary <- cleaned_data_filtered %>%
  group_by(ID, Serial.Number) %>%
  summarise(
    First_Timestamp = min(Timestamp, na.rm = TRUE),
    Last_Timestamp = max(Timestamp, na.rm = TRUE),
    Count = n(),
    .groups = "drop"
  ) %>%
  arrange(ID, First_Timestamp)

serial_number_summary
```
### Create Dataset without duplicates

**Description** Step 1: deduplicate: exact duplicates
```{r}
cleaned_data_deduplicated <- cleaned_data_filtered %>%
  distinct(ID, Timestamp, Serial.Number, `Glucose (mg/dl)`, .keep_all = TRUE)
```
**Description** Step 2: deduplicate: duplicates with same timestamp and glucose value but not same serial number
```{r}
cleaned_data_deduplicated <- cleaned_data_deduplicated %>%
  distinct(ID, Timestamp, `Glucose (mg/dl)`, .keep_all = TRUE)
```
**Description** Step 3: deduplicate: duplicates with same timestamp but different glucose value
```{r}
cleaned_data_deduplicated <- anti_join(
  cleaned_data_deduplicated,
  conflicting_duplicates,
  by = c("ID", "Timestamp", "Serial.Number", "Glucose (mg/dl)")
)
```
**Description**: check how many rows were deleted
```{r}
nrow(cleaned_data_filtered) - nrow(cleaned_data_deduplicated)
```
### Missings in Duplicated Dataset
**Description:** per ID, check how many data points there are from the first day of measurement on for one year

```{r}
# 102
target_id_102 <- "102"               
start_date_102 <- as.Date("2024-03-11")  

# Filter for this ID and 1-year window
filtered_data_102 <- cleaned_data_deduplicated %>%
  filter(
    ID == target_id_102,
    Timestamp >= start_date_102,
    Timestamp < start_date_102 + years(1)
  )

# Count number of measurements
measurement_count_102 <- nrow(filtered_data_102)



# 104
target_id_104 <- "104"
start_date_104 <- as.Date("2024-03-18") 

# Filter for this ID and 1-year window
filtered_data_104 <- cleaned_data_deduplicated %>%
  filter(
    ID == target_id_104,
    Timestamp >= start_date_104,
    Timestamp < start_date_104 + years(1)
  )

# Count number of measurements
measurement_count_104 <- nrow(filtered_data_104)


# 107
target_id_107 <- "107"            
start_date_107 <- as.Date("2024-03-25") 

# Filter for this ID and 1-year window
filtered_data_107 <- cleaned_data_deduplicated %>%
  filter(
    ID == target_id_107,
    Timestamp >= start_date_107,
    Timestamp < start_date_107 + years(1)
  )

# Count number of measurements
measurement_count_107 <- nrow(filtered_data_107)


# 108
target_id_108 <- "108"              
start_date_108 <- as.Date("2024-04-22")  

# Filter for this ID and 1-year window
filtered_data_108 <- cleaned_data_deduplicated %>%
  filter(
    ID == target_id_108,
    Timestamp >= start_date_108,
    Timestamp < start_date_108 + years(1)
  )

# Count number of measurements
measurement_count_108 <- nrow(filtered_data_108)


# 109
target_id_109 <- "109"            
start_date_109 <- as.Date("2024-04-22")

# Filter for this ID and 1-year window
filtered_data_109 <- cleaned_data_deduplicated %>%
  filter(
    ID == target_id_109,
    Timestamp >= start_date_109,
    Timestamp < start_date_109 + years(1)
  )

# Count number of measurements
measurement_count_109 <- nrow(filtered_data_109)

# 112
target_id_112 <- "112"            
start_date_112 <- as.Date("2024-08-11")  

# Filter for this ID and 1-year window
filtered_data_112 <- cleaned_data_deduplicated %>%
  filter(
    ID == target_id_112,
    Timestamp >= start_date_112,
    Timestamp < start_date_112 + years(1)
  )

# Count number of measurements
measurement_count_112 <- nrow(filtered_data_112)
```

## Time in range
### General overview on hyper and hypo glucose per ID
**Description:** hypo < 70 and hyper > 180
```{r}
 cleaned_data_deduplicated %>%
  mutate(
    Glucose_Category = case_when(
      `Glucose (mg/dl)` < 70 ~ "Hypo",
      `Glucose (mg/dl)` > 180 ~ "Hyper",
      TRUE ~ "Normal"
    )
  ) %>%
  group_by(ID, Glucose_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(ID) %>%
  mutate(Percentage = round(Count / sum(Count) * 100, 2))
```
### Hyper and Hypo in Day and Night
**Description**: Adding Day and Night to Dataset: Night from 22h to 6h
```{r}
cleaned_data_deduplicated <- cleaned_data_deduplicated %>%
  mutate(
    Hour = hour(Timestamp),
    Time_of_Day = case_when(
      Hour >= 6 & Hour < 22 ~ "Day",
      TRUE ~ "Night"
    )
  )
```
**Description**: Hyper and Hypo in Day and Night

```{r}
cleaned_data_deduplicated %>%
  mutate(
    Glucose_Category = case_when(
      `Glucose (mg/dl)` < 70 ~ "Hypo",
      `Glucose (mg/dl)` > 180 ~ "Hyper",
      TRUE ~ "Normal"
    )
  ) %>%
  group_by(ID, Time_of_Day, Glucose_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(ID, Time_of_Day) %>%
  mutate(Percentage = round(Count / sum(Count) * 100, 2)) %>%
  kable()
```
**Description**: Hyper and Hypo clinically split 
```{r}

cleaned_data_deduplicated %>%
  mutate(
    Glucose_Category = case_when(
      `Glucose (mg/dl)` < 54 ~ "Very Low",                        # Severe Hypo
      `Glucose (mg/dl)` >= 54 & `Glucose (mg/dl)` < 70 ~ "Low",  # Mild Hypo
      `Glucose (mg/dl)` >= 70 & `Glucose (mg/dl)` <= 180 ~ "Normal", # In Range
      `Glucose (mg/dl)` > 180 & `Glucose (mg/dl)` <= 250 ~ "High",  # High
      `Glucose (mg/dl)` > 250 ~ "Very High"                          # Very High
    )
  ) %>%
  group_by(ID, Time_of_Day, Glucose_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(ID, Time_of_Day) %>%
  mutate(Percentage = round(Count / sum(Count) * 100, 2)) %>%
  kable()
```
### Create a Graph
**Description**: Create color code
```{r}
glucose_category_colors <- c(
  "Very Low" = "#990000",   # dark red
  "Low" = "#e60000",        # lighter red
  "Normal" = "#228B22",     # green
  "High" = "#FFA500",       # orange
  "Very High" = "#CC5500"   # dark orange
)
```
**Description**: Add glucose category to dataset
```{r}
cleaned_data_deduplicated <- cleaned_data_deduplicated %>%
  mutate(
    Glucose_Category = case_when(
      `Glucose (mg/dl)` < 54 ~ "Very Low",
      `Glucose (mg/dl)` >= 54 & `Glucose (mg/dl)` < 70 ~ "Low",
      `Glucose (mg/dl)` >= 70 & `Glucose (mg/dl)` <= 180 ~ "Normal",
      `Glucose (mg/dl)` > 180 & `Glucose (mg/dl)` <= 250 ~ "High",
      `Glucose (mg/dl)` > 250 ~ "Very High"
    )
  )
```
**Description**: Create Summary of time in range
```{r}
time_in_range_summary <- cleaned_data_deduplicated %>%
  mutate(
    Glucose_Category = case_when(
      `Glucose (mg/dl)` < 54 ~ "Very Low",
      `Glucose (mg/dl)` >= 54 & `Glucose (mg/dl)` < 70 ~ "Low",
      `Glucose (mg/dl)` >= 70 & `Glucose (mg/dl)` <= 180 ~ "Normal",
      `Glucose (mg/dl)` > 180 & `Glucose (mg/dl)` <= 250 ~ "High",
      `Glucose (mg/dl)` > 250 ~ "Very High"
    )
  ) %>%
  group_by(ID, Time_of_Day, Glucose_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(ID, Time_of_Day) %>%
  mutate(Percentage = round(Count / sum(Count) * 100, 1))
```
**Description**: Create Bar
```{r}
category_colors <- c(
  "Very Low" = "#990000",
  "Low" = "#e60000",
  "Normal" = "#228B22",
  "High" = "#FFA500",
  "Very High" = "#CC5500"
)

ggplot(time_in_range_summary, aes(x = Time_of_Day, y = Percentage, fill = Glucose_Category)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = category_colors) +
  facet_wrap(~ ID, ncol = 2) +
  labs(
    title = "Glucose Ranges by Time of Day",
    x = "Time of Day",
    y = "Percentage",
    fill = "Glucose Category"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    strip.text = element_text(face = "bold")
  )
```
**Description**: Create a different Graph
```{r}
time_in_range_summary <- time_in_range_summary %>%
  mutate(Glucose_Category = factor(
    Glucose_Category,
    levels = c("Very Low", "Low", "Normal", "High", "Very High")
  ))


ggplot(time_in_range_summary, aes(x = Glucose_Category, y = Percentage, color = Glucose_Category)) +
  geom_segment(aes(xend = Glucose_Category, y = 0, yend = Percentage), size = 0.8) +
  geom_point(size = 3) +
  geom_text(
    aes(label = paste0(Percentage, "%")),
    hjust = -0.4,
    size = 3,
    color = "black"
  ) +
  scale_color_manual(values = category_colors) +
  facet_grid(ID ~ Time_of_Day) +
  coord_flip(ylim = c(0, 130)) +  # <- Add more space beyond 100%
  labs(
    title = "Glucose Category by ID and Time of Day",
    x = "Category",
    y = "Percentage (%)"
  ) +
  theme_minimal()

```
**Description:** Plot a donut chart
```{r}
donut_data <- time_in_range_summary %>%
  filter(ID == "102", Time_of_Day == "Night")

ggplot(donut_data, aes(x = 2, y = Percentage, fill = Glucose_Category)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar(theta = "y") +
  xlim(0.5, 2.5) +  # creates the hole (donut)
  scale_fill_manual(values = category_colors) +
  geom_text(aes(label = paste0(Percentage, "%")),
            position = position_stack(vjust = 0.5), size = 3, color = "black") +
  theme_void() +
  labs(title = "Glucose Distribution (Night) – 102",
       fill = "Glucose Category") +
  theme(legend.position = "right")
```
### Stacked Chart
**Description:** Prepare Dataset
```{r}
  stacked_chart <- cleaned_data_deduplicated %>%
    filter(!is.na(Glucose_Category)) %>%
    mutate(
      Time = floor_date(Timestamp, "5 minutes"),
      TimeOnly = format(Time, "%H:%M:%S"),
      # POSIXct with reference date
      TimeOnly_POSIX = as.POSIXct(TimeOnly, format = "%H:%M:%S", tz = "UTC")
    ) %>%
    count(ID, TimeOnly_POSIX, Glucose_Category) %>%
    group_by(ID, TimeOnly_POSIX) %>%
    mutate(percentage = n / sum(n)) %>%
    ungroup() %>%
    complete(ID, TimeOnly_POSIX, Glucose_Category, fill = list(n = 0, percentage = 0)) %>%
    mutate(
      Glucose_Category = factor(Glucose_Category, levels = c("High", "Normal", "Low", "Very Low"))
    )
```
**Description:** Plot for One ID
```{r}
  ggplot(stacked_chart %>% filter(ID == "102"), 
         aes(x = TimeOnly_POSIX, y = percentage, fill = Glucose_Category)) +
    geom_area() +
    scale_x_datetime(date_labels = "%H:%M") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
**Description:** Plot for all IDs
```{r}
  ggplot(stacked_chart, 
         aes(x = TimeOnly_POSIX, y = percentage, fill = Glucose_Category)) +
    geom_area() +
    scale_x_datetime(date_labels = "%H:%M") +
    facet_wrap(~ ID, ncol = 2) +  
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
### Improved visualization of High, Low and Very Low 
**Description:** Facet per Category and ID
```{r}
 ggplot(stacked_chart, 
         aes(x = TimeOnly_POSIX, y = percentage)) +
    geom_area(fill = "steelblue") +
    facet_grid(Glucose_Category ~ ID) +  # Facet per Category & ID
    scale_x_datetime(date_labels = "%H:%M") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(y = "Proportion", x = "Time of Day")
```
**Description:** log10
```{r}
ggplot(stacked_chart, 
         aes(x = TimeOnly_POSIX, y = percentage, fill = Glucose_Category)) +
    geom_area() +
    scale_x_datetime(date_labels = "%H:%M") +
    scale_y_log10()+
    facet_wrap(~ ID, ncol = 2) +  
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
**Description:** Show lower 25% only
```{r}
# Reorder "High" to make visualization possible
stacked_chart_25 <- stacked_chart %>%
  mutate(
      Glucose_Category = factor(Glucose_Category, levels = c("Normal", "High", "Low", "Very Low")))

 ggplot(stacked_chart_25, 
         aes(x = TimeOnly_POSIX, y = percentage, fill = Glucose_Category)) +
    geom_area() +
    scale_x_datetime(date_labels = "%H:%M") +
    coord_cartesian(ylim = c(0, 0.25)) +  # only show until 25%
    facet_wrap(~ ID, ncol = 2) +  
    labs(y = "Proportion", x = "Time of Day") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1))
```

## Spike analysis
### Category Change
**Description**: How often does the glucose value change from one category to another
```{r}
# Prepare data
spike_analysis <- cleaned_data_deduplicated %>%
  arrange(ID, Timestamp) %>%
  mutate(
    Glucose_Category = case_when(
      `Glucose (mg/dl)` < 54 ~ "Very Low",
      `Glucose (mg/dl)` >= 54 & `Glucose (mg/dl)` < 70 ~ "Low",
      `Glucose (mg/dl)` >= 70 & `Glucose (mg/dl)` <= 180 ~ "Normal",
      `Glucose (mg/dl)` > 180 & `Glucose (mg/dl)` <= 250 ~ "High",
      `Glucose (mg/dl)` > 250 ~ "Very High"
    ),
    Prev_Category = lag(Glucose_Category),
    Prev_ID = lag(ID),
    Prev_Time_of_Day = lag(Time_of_Day),
    Spike = Glucose_Category != Prev_Category & ID == Prev_ID & Time_of_Day == Prev_Time_of_Day
  ) %>%
  filter(Spike) %>%
  mutate(
    From = Prev_Category,
    To = Glucose_Category
  ) %>%
  mutate(
    Spike_Direction = paste0(Prev_Category, " → ", Glucose_Category)
  ) %>%
  group_by(ID, Time_of_Day, Spike_Direction, From, To) %>%
  summarise(Spike_Count = n(), .groups = "drop")



spike_percent <- spike_analysis %>%
  group_by(ID, Time_of_Day) %>%
  mutate(
    Total_Spikes = sum(Spike_Count),
    Percentage = round(100 * Spike_Count / Total_Spikes, 1)
  ) %>%
  ungroup()
```
**Description:** Plot the Category Change in Percent
```{r}
ggplot(spike_percent, aes(x = Spike_Direction, y = Percentage, fill = Spike_Direction)) +
  geom_col() +
  coord_flip() +
  facet_grid(ID ~ Time_of_Day) +  # Rows = IDs, Columns = Day/Night
  labs(
    title = "Changes Between Glucose Categories (Spikes)",
    x = "Category Changes",
    y = "Percentage (%)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 10)
  )
```
**Description:** Plot the Category Change in Count
```{r}
ggplot(spike_analysis, aes(x = Spike_Direction, y = Spike_Count, fill = Spike_Direction)) +
  geom_col() +
  facet_wrap(~ ID) +
  coord_flip() +
  labs(
    title = "Changes Between Glucose Categories (Spikes)",
    x = "Category Change",
    y = "Count"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

**Description:** Create a heat map
```{r}
category_levels <- c("Very Low", "Low", "Normal", "High", "Very High")

spike_percent <- spike_percent %>%
  mutate(
    From = factor(From, levels = category_levels),
    To = factor(To, levels = category_levels)
  )

ggplot(spike_percent, aes(x = To, y = From, fill = Percentage)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Percentage), size = 3) +
  facet_grid(ID ~ Time_of_Day) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(
    title = "Transition Heatmap Between Glucose Categories",
    x = "Current Category",
    y = "Previous Category",
    fill = "Percent (%)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  )

```
**Description**: Creat a heatmap with heatmap() function and for all IDs
```{r}
library(pheatmap)

# Summarise raw counts, not percentages
overall_data <- spike_analysis %>%
  separate(Spike_Direction, into = c("From", "To"), sep = " → ") %>%
  group_by(From, To) %>%
  summarise(Total_Spike_Count = sum(Spike_Count), .groups = "drop")

# Total transitions for percentage calculation
total_spikes_all <- sum(overall_data$Total_Spike_Count)

# Compute true overall percentage
overall_data <- overall_data %>%
  mutate(
    Percentage = round(100 * Total_Spike_Count / total_spikes_all, 1),
    From = factor(From, levels = category_levels),
    To = factor(To, levels = category_levels)
  )


# Create matrix for pheatmap with reversed row order
heatmap_matrix <- matrix(
  0, 
  nrow = length(category_levels), 
  ncol = length(category_levels),
  dimnames = list(From = rev(category_levels), To = category_levels)
)

# Populate matrix
for (i in seq_len(nrow(overall_data))) {
  row <- overall_data$From[i]
  col <- overall_data$To[i]
  val <- overall_data$Percentage[i]
  heatmap_matrix[as.character(row), as.character(col)] <- val
}

# Plot with correct percentages: using pheatmap() function to be able to integrate percentages
pheatmap(
  heatmap_matrix,
  display_numbers = TRUE,
  number_format = "%.1f",  
  color = colorRampPalette(c("white", "steelblue"))(100),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  main = "Category Change (Overall Study Percentage)",
  angle_col = 45
)
```
### Spike Duration
```{r}
spike_durations <- cleaned_data_deduplicated %>%
  arrange(ID, Timestamp) %>%
  mutate(
    Glucose_Category = case_when(
      `Glucose (mg/dl)` < 54 ~ "Very Low",
      `Glucose (mg/dl)` >= 54 & `Glucose (mg/dl)` < 70 ~ "Low",
      `Glucose (mg/dl)` >= 70 & `Glucose (mg/dl)` <= 180 ~ "Normal",
      `Glucose (mg/dl)` > 180 & `Glucose (mg/dl)` <= 250 ~ "High",
      `Glucose (mg/dl)` > 250 ~ "Very High"
    ),
    Category_Change = Glucose_Category != lag(Glucose_Category) | ID != lag(ID)
  ) %>%
  # Group consecutive identical categories per ID
  mutate(Spike_Group = cumsum(replace_na(Category_Change, TRUE))) %>%
  group_by(ID, Spike_Group) %>%
  summarise(
    Start = min(Timestamp),
    End = max(Timestamp),
    Duration_min = as.numeric(difftime(max(Timestamp), min(Timestamp), units = "mins")),
    Category = first(Glucose_Category),
    .groups = "drop"
  ) %>%
  # Filter for spikes only (exclude normal periods)
  filter(Category != "Normal")

# View spike durations
head(spike_durations)
```
**Description:** Plot the Statistics of Spike Duration
```{r}
# overall statistics
spike_stats <- spike_durations %>%
  group_by(Category) %>%
  summarise(
    Count = n(),
    Median_Duration = median(Duration_min),
    Mean_Duration = round(mean(Duration_min), 1),
    Max_Duration = max(Duration_min),
    Min_Duration = min(Duration_min),
    .groups = "drop"
  )

# statistics per ID

spike_subject_stats <- spike_durations %>%
  group_by(ID, Category) %>%
  summarise(
    Episodes = n(),
    Total_Duration = sum(Duration_min),
    Median_Duration = median(Duration_min),
    .groups = "drop"
  )
```
**Description:** Plot the Frequency of Glucose Spike Duration
```{r}
ggplot(spike_durations, aes(x = Duration_min, fill = Category)) +
  geom_bar(position = "stack") +
  facet_wrap(~ ID) +
  labs(
    title = "Frequency of Glucose Spike Durations by Category",
    x = "Spike Duration (minutes)",
    y = "Count",
    fill = "Glucose Category"
  ) +
  coord_cartesian(xlim = c(0, 200)) + # scale only until 200, for the most frequent durations
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```
**Description:** Plot the Spikes over time
```{r}
ggplot(spike_durations, aes(x = Start, xend = End, y = ID, yend = ID, color = Category)) +
  geom_segment(size = 8) +
  scale_color_manual(values = category_colors) +  # Optional: your color scheme
  labs(
    title = "Glucose Spikes Over Time",
    x = "Time",
    y = "Participant ID",
    color = "Glucose Category"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    axis.text.y = element_text(face = "bold")
  )
```

## Day and Night Analysis
### Defining Day and Night
```{r}
cleaned_data_deduplicated <- cleaned_data_deduplicated %>%
  mutate(
    Hour = hour(Timestamp),
    Time_of_Day = case_when(
      Hour >= 6 & Hour < 22 ~ "Day",
      TRUE ~ "Night"
    )
  )
```
### Plotting Day vs Night
**Description:** Plot 1
```{r}
ggplot(cleaned_data_deduplicated, aes(x = Timestamp, y = `Glucose (mg/dl)`, color = Time_of_Day)) +
  geom_point(alpha = 0.5, size = 0.8) +
  facet_wrap(~ ID) +
  labs(color = "Time of Day", title = "Glucose Values over Time: Day vs. Night")+
  theme_minimal()+
   theme(
    legend.position = "top",
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
   )

ggplot(cleaned_data_deduplicated, aes(x = Time_of_Day, y = `Glucose (mg/dl)`, fill = Time_of_Day)) +
  geom_boxplot(alpha = 0.5) +
  facet_wrap(~ ID) +
  theme_minimal() +
  labs(title = "Glucose Values: Day vs. Night",fill = "Time of Day" , x = "", y = "Glucose (mg/dl)")
```
**Description:** Table for numbers of boxplot
```{r}
glucose_summary_table <- cleaned_data_deduplicated %>%
  group_by(ID, Time_of_Day) %>%
  summarise(
    n = n(),
    Median = median(`Glucose (mg/dl)`, na.rm = TRUE),
    Mean = round(mean(`Glucose (mg/dl)`, na.rm = TRUE), 1),
    Min = min(`Glucose (mg/dl)`, na.rm = TRUE),
    Q1 = quantile(`Glucose (mg/dl)`, 0.25, na.rm = TRUE),
    Q3 = quantile(`Glucose (mg/dl)`, 0.75, na.rm = TRUE),
    Max = max(`Glucose (mg/dl)`, na.rm = TRUE),
    .groups = "drop"
  )
```
**Description:** Plot 2
```{r}
ggplot(cleaned_data_deduplicated, aes(x = Timestamp, y = `Glucose (mg/dl)`, color = Time_of_Day)) +geom_point(alpha = 0.3, size = 1) +
  geom_smooth(method = "loess", se = FALSE) +
  facet_wrap(~ ID) +
  scale_color_manual(values = c("Day" = "orange3", "Night" = "midnightblue")) +
  labs(
    title = "Glucose trend over time: Day vs. Night",
    x = "Time",
    y = "Glucose (mg/dl)",
    color = "Time of Day"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```
**Description:** Plot 3: Daily mean over time + standard deviation
```{r}
# create dataset with mean and standard deviation
  cleaned_summary <- cleaned_data_deduplicated %>%
    mutate(
      Date = as.Date(Timestamp)  # date of day
    ) %>%
    group_by(ID, Time_of_Day, Date) %>%
    summarise(
      mean_glucose = mean(`Glucose (mg/dl)`, na.rm = TRUE),
      sd_glucose   = sd(`Glucose (mg/dl)`, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Create Plot
  ggplot(cleaned_summary, aes(x = Date, y = mean_glucose, color = Time_of_Day, fill = Time_of_Day)) +
    geom_smooth(size = 0.5) +
    geom_ribbon(aes(ymin = mean_glucose - sd_glucose, ymax = mean_glucose + sd_glucose), alpha = 0.2, color = NA) +
    facet_wrap(~ ID) +
    scale_color_manual(values = c("Day" = "orange3", "Night" = "midnightblue")) +
    scale_fill_manual(values = c("Day" = "orange3", "Night" = "midnightblue")) +
    labs(
      title = "Daily Mean Glucose with Standard Deviation (Day vs. Night)",
      x = "Date",
      y = "Mean Glucose (mg/dl)",
      color = "Time of Day",
      fill = "Time of Day"
    ) +
    theme_minimal() +
    theme(
      legend.position = "top",
      strip.text = element_text(face = "bold"),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
``` 
### Nighttime Glucose: Hourly Bins
**Description:** Prepare Data for Graph
```{r}
# Filter for night data
night_data <- cleaned_data_deduplicated %>%
  mutate(Hour = hour(Timestamp)) %>%
  filter(Hour >= 22 | Hour < 7) %>%  # Nighttime: 22 to 6:59
  
  # Create reordered factor for plotting (22 to 6)
  mutate(Hour_Factor = factor(Hour, levels = c(22, 23, 0, 1, 2, 3, 4, 5, 6)))

# Calculate average glucose per hour per ID
night_avg <- night_data %>%
  group_by(ID, Hour_Factor) %>%
  summarise(
    Avg_Glucose = mean(`Glucose (mg/dl)`, na.rm = TRUE),
    .groups = "drop"
  )
```
**Description:** Plot the night
```{r}
ggplot(night_avg, aes(x = Hour_Factor, y = Avg_Glucose, group = ID, color = ID)) +
  geom_line(size = 1) +
  geom_point(size = 1.5) +
  labs(
    title = "Nighttime Glucose Trends per ID",
    subtitle = "Hours from 22:00 to 06:59: hourly bins",
    x = "Hour of Night",
    y = "Average Glucose (mg/dl)",
    color = "ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  )
```
**Description:** Boxplot of Average Glucose per Hour
```{r}
#boxplot
ggplot(night_data, aes(x = Hour_Factor, y = `Glucose (mg/dl)`, fill = Hour_Factor)) +
  geom_boxplot(outlier.size = 0.2, alpha = 0.6) +
  facet_wrap(~ ID, ncol = 2) +
  scale_fill_brewer(palette = "Blues") +
  labs(
    title = "Nighttime Glucose Distribution per Hour and ID",
    subtitle = "Hours from 22:00 to 06:59",
    x = "Hour of Night",
    y = "Glucose (mg/dl)",
    fill = "Hour"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  )
```
### Nighttime Glucose: 5min bins
```{r}
# create 5min bins
night_data <- night_data %>%
  mutate(Minute5 = floor_date(Timestamp, unit = "5 minutes"),
         Minute5 = format(Minute5, "%H:%M"))

# calculate mean and standard deviation
night_avg_5 <- night_data %>%
  group_by(ID, Minute5) %>%
  summarise(
    Avg_Glucose_5 = mean(`Glucose (mg/dl)`, na.rm = TRUE),
    Sd_Glucose_5 = sd(`Glucose (mg/dl)`, na.rm = TRUE),
    .groups = "drop"
  )


# create levels for right order
levels_ordered <- format(seq.POSIXt(
  from = as.POSIXct("2024-01-01 22:00"),
  to   = as.POSIXct("2024-01-02 06:00"),
  by   = "5 min"
), "%H:%M")

# create reordered factor for plotting
night_avg_5 <- night_avg_5 %>%
  mutate(Minute5_Factor = factor(Minute5, levels = levels_ordered))

# cretae labels for x axis
hour_labels <- format(seq.POSIXt(
  from = as.POSIXct("2024-01-01 22:00"),
  to = as.POSIXct("2024-01-02 06:00"),
  by = "1 hour"
), "%H:%M")

# create one plot for all
ggplot(night_avg_5, aes(x = Minute5_Factor, y = Avg_Glucose_5, group = ID, color = ID, fill = ID)) +
  geom_smooth(size = 0.8) +
  geom_line(size = 0.5) +
  geom_ribbon(aes(ymin = Avg_Glucose_5 - Sd_Glucose_5, ymax = Avg_Glucose_5 + Sd_Glucose_5), alpha = 0.1, color = NA)+
  scale_x_discrete(breaks = hour_labels) +
  labs(
    title = "Nighttime Glucose Trends per ID",
    subtitle = "Hours from 22:00 to 06:00: 5min bins",
    x = "Hour of Night",
    y = "Average Glucose (mg/dl)",
    color = "ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  )   

# create on eplot per ID
ggplot(night_avg_5, aes(x = Minute5_Factor, y = Avg_Glucose_5, group = ID, color = ID, fill = ID)) +
  geom_smooth(size = 0.7) +
  geom_line(size = 0.5) +
  geom_ribbon(aes(ymin = Avg_Glucose_5 - Sd_Glucose_5, ymax = Avg_Glucose_5 + Sd_Glucose_5), alpha = 0.1, color = NA)+
  scale_x_discrete(breaks = hour_labels) +
  facet_wrap(~ ID) +
  labs(
    title = "Nighttime Glucose Trends per ID",
    subtitle = "Hours from 22:00 to 06:00: 5min bins",
    x = "Hour of Night",
    y = "Average Glucose (mg/dl)",
    color = "ID"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  ) 
```
### Create a double plot

```{r}
# Extract time-of-day in hours and add ID names without "Ecosleep"
double_data <- cleaned_data_deduplicated %>%
  mutate(
    Date = as.Date(Timestamp),
    Hour = hour(Timestamp),
    Minute = minute(Timestamp),
    Time_of_Day = Hour + Minute / 60,
  )

# Duplicate data: original time + shifted by 24h
double_data_long <- bind_rows(
  double_data %>% mutate(Double_Hour = Time_of_Day),
  double_data %>% mutate(Double_Hour = Time_of_Day + 24)
)

# Round down to full hour and keep the original 0–47 factor for correct time ordering
double_avg <- double_data_long %>%
  mutate(Hour_Rounded = floor(Double_Hour)) %>%
  group_by(ID, Hour_Rounded) %>%
  summarise(Avg_Glucose = mean(`Glucose (mg/dl)`, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    Display_Hour = Hour_Rounded %% 24,
    Day = ifelse(Hour_Rounded < 24, "Day 1", "Day 2"),
    Hour_Label = paste0(Day, " – ", sprintf("%02d:00", Display_Hour)),
    Hour_Factor = factor(Hour_Label, levels = c(
      paste0("Day 1 – ", sprintf("%02d:00", 0:23)),
      paste0("Day 2 – ", sprintf("%02d:00", 0:23))
    ))
  )


# Create the plot
ggplot(double_avg, aes(x = Hour_Factor, y = Avg_Glucose, group = ID, color = ID)) +
  geom_line(size = 1) +
  geom_point(size = 1.5) +
  labs(
    title = "Double Plot: 48-Hour Glucose Trends per ID",
    subtitle = "Same 24h cycle shown twice to visualize rhythm",
    x = "Hour of Day (Repeated)",
    y = "Average Glucose (mg/dl)",
    color = "ID"
  ) +
  scale_y_continuous(limits = c(85, 120)) +
  scale_x_discrete(
    breaks = levels(double_avg$Hour_Factor)[seq(1, 48, by = 4)]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, size = 7),
    strip.text = element_text(face = "bold")
  )
```
## Cosine fit
### First fit for every ID
```{r}
# Filter data for ID 102
fit_data_102 <- double_avg %>% filter(ID == "102")

# Fit cosine model (period 24h)
cos_fit_102 <- nls(
  Avg_Glucose ~ A * cos(2 * pi / 24 * Hour_Rounded + phi) + C,
  data = fit_data_102,
  start = list(A = 10, phi = 0, C = 100)  # rough starting guesses
)

summary(cos_fit_102)

# Add predicted values
fit_data_102 <- fit_data_102 %>%
  mutate(Fitted = predict(cos_fit_102))

# Plot actual vs fitted
ggplot(fit_data_102, aes(x = Hour_Rounded)) +
  geom_point(aes(y = Avg_Glucose), color = "blue") +
  geom_line(aes(y = Fitted), color = "red") +
  labs(
    title = "Cosine Fit for 102",
    x = "Hour of Day (0–47)",
    y = "Average Glucose (mg/dl)"
  ) +
  theme_minimal()


fit_data_104 <- double_avg %>% filter(ID == "104")
cos_fit_104 <- nls(
  Avg_Glucose ~ A * cos(2 * pi / 24 * Hour_Rounded + phi) + C,
  data = fit_data_104,
  start = list(A = 10, phi = 0, C = 100)
)
fit_data_104 <- fit_data_104 %>%
  mutate(Fitted = predict(cos_fit_104))
ggplot(fit_data_104, aes(x = Hour_Rounded)) +
  geom_point(aes(y = Avg_Glucose), color = "blue") +
  geom_line(aes(y = Fitted), color = "red") +
  labs(
    title = "Cosine Fit for 104",
    x = "Hour of Day (0–47)",
    y = "Average Glucose (mg/dl)"
  ) +
  theme_minimal()


fit_data_107 <- double_avg %>% filter(ID == "107")

cos_fit_107 <- nls(
  Avg_Glucose ~ A * cos(2 * pi / 24 * Hour_Rounded + phi) + C,
  data = fit_data_107,
  start = list(A = 10, phi = 0, C = 100)
)

fit_data_107 <- fit_data_107 %>%
  mutate(Fitted = predict(cos_fit_107))

ggplot(fit_data_107, aes(x = Hour_Rounded)) +
  geom_point(aes(y = Avg_Glucose), color = "blue") +
  geom_line(aes(y = Fitted), color = "red") +
  labs(
    title = "Cosine Fit for 107",
    x = "Hour of Day (0–47)",
    y = "Average Glucose (mg/dl)"
  ) +
  theme_minimal()


fit_data_108 <- double_avg %>% filter(ID == "108")

cos_fit_108 <- nls(
  Avg_Glucose ~ A * cos(2 * pi / 24 * Hour_Rounded + phi) + C,
  data = fit_data_108,
  start = list(A = 10, phi = 0, C = 100)
)

fit_data_108 <- fit_data_108 %>%
  mutate(Fitted = predict(cos_fit_108))

ggplot(fit_data_108, aes(x = Hour_Rounded)) +
  geom_point(aes(y = Avg_Glucose), color = "blue") +
  geom_line(aes(y = Fitted), color = "red") +
  labs(
    title = "Cosine Fit for 108",
    x = "Hour of Day (0–47)",
    y = "Average Glucose (mg/dl)"
  ) +
  theme_minimal()

fit_data_109 <- double_avg %>% filter(ID == "109")

cos_fit_109 <- nls(
  Avg_Glucose ~ A * cos(2 * pi / 24 * Hour_Rounded + phi) + C,
  data = fit_data_109,
  start = list(A = 10, phi = 0, C = 100)
)

fit_data_109 <- fit_data_109 %>%
  mutate(Fitted = predict(cos_fit_109))

ggplot(fit_data_109, aes(x = Hour_Rounded)) +
  geom_point(aes(y = Avg_Glucose), color = "blue") +
  geom_line(aes(y = Fitted), color = "red") +
  labs(
    title = "Cosine Fit for 109",
    x = "Hour of Day (0–47)",
    y = "Average Glucose (mg/dl)"
  ) +
  theme_minimal()


fit_data_112 <- double_avg %>% filter(ID == "112")

cos_fit_112 <- nls(
  Avg_Glucose ~ A * cos(2 * pi / 24 * Hour_Rounded + phi) + C,
  data = fit_data_112,
  start = list(A = 10, phi = 0, C = 100)
)

fit_data_112 <- fit_data_112 %>%
  mutate(Fitted = predict(cos_fit_112))

ggplot(fit_data_112, aes(x = Hour_Rounded)) +
  geom_point(aes(y = Avg_Glucose), color = "blue") +
  geom_line(aes(y = Fitted), color = "red") +
  labs(
    title = "Cosine Fit for 112",
    x = "Hour of Day (0–47)",
    y = "Average Glucose (mg/dl)"
  ) +
  theme_minimal()



# Maximum bestimmen
max_row <- fit_data_102 %>% filter(Fitted == max(Fitted))
cat("Maximum:\n")
print(max_row %>% select(Hour_Rounded, Fitted))

# Minimum bestimmen
min_row <- fit_data_102 %>% filter(Fitted == min(Fitted))
cat("\nMinimum:\n")
print(min_row %>% select(Hour_Rounded, Fitted))
```
### Cosinus fit with cosinor()
**Description**: load cosinor package
```{r}
library(cosinor)
```
**Description**: Test functioning of the package with vitamind data set
```{r}
data("vitamind")
 head(vitamind)

 fit <- cosinor.lm(Y ~ time(time) + X + amp.acro(X), data = vitamind, period = 12) 
summary(fit) 

test_cosinor(fit, "X", param = "amp")
summary(vitamind$Y)
summary(predict(fit))
library(ggplot2)
ggplot_cosinor.lm(fit, x_str = "X")
```

**Description**: fit cosinor for ID 102
```{r}
# create dataset for cosinor model for 102
glucose_fit_102_data <- cleaned_data_deduplicated %>%
  filter(ID == "102") %>%    # filter for 102
  mutate(
    datetime = dmy_hm(DeviceTimestamp),  #  if format TT-MM-JJJJ HH:MM
    dec.time = hour(datetime) + minute(datetime) / 60  # time as decimal hour during the day
  )

# cosinor model
glucose_fit_102 <- cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = glucose_fit_102_data, period = 24) 
summary(glucose_fit_102) 

# raw values
summary(glucose_fit_102_data$`Glucose (mg/dl)`)

# adjusted values
summary(predict(glucose_fit_102))

# plot the fit
ggplot_cosinor.lm(glucose_fit_102)
```
**Description**: fit cosinor for Ecosleep 104
```{r}
# create dataset for cosinor model for 102Ecosleep
glucose_fit_104_data <- cleaned_data_deduplicated %>%
  filter(ID == "104") %>%    # filter for 104
  mutate(
    datetime = dmy_hm(DeviceTimestamp),  #  if format TT-MM-JJJJ HH:MM
    dec.time = hour(datetime) + minute(datetime) / 60  # time as decimal hour during the day
  )

# cosinor model
glucose_fit_104 <- cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = glucose_fit_104_data, period = 24) 
summary(glucose_fit_102) 

# raw values
summary(glucose_fit_104_data$`Glucose (mg/dl)`)

# adjusted values
summary(predict(glucose_fit_104))

# plot the fit
ggplot_cosinor.lm(glucose_fit_104)
```
**Description**: fit cosinor for Ecosleep 107
```{r}
# create dataset for cosinor model for 107Ecosleep
glucose_fit_107_data <- cleaned_data_deduplicated %>%
  filter(ID == "107") %>%    # filter for 107
  mutate(
    datetime = dmy_hm(DeviceTimestamp),  #  if format TT-MM-JJJJ HH:MM
    dec.time = hour(datetime) + minute(datetime) / 60  # time as decimal hour during the day
  )

# cosinor model
glucose_fit_107 <- cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = glucose_fit_107_data, period = 24) 
summary(glucose_fit_107) 

# raw values
summary(glucose_fit_107_data$`Glucose (mg/dl)`)

# adjusted values
summary(predict(glucose_fit_107))

# plot the fit
ggplot_cosinor.lm(glucose_fit_107)
```
**Description**: fit cosinor for Ecosleep 108
```{r}
# create dataset for cosinor model for 107Ecosleep
glucose_fit_108_data <- cleaned_data_deduplicated %>%
  filter(ID == "108") %>%    # filter for 107
  mutate(
    datetime = dmy_hm(DeviceTimestamp),  #  if format TT-MM-JJJJ HH:MM
    dec.time = hour(datetime) + minute(datetime) / 60  # time as decimal hour during the day
  )

# cosinor model
glucose_fit_108 <- cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = glucose_fit_108_data, period = 24) 
summary(glucose_fit_108) 

# raw values
summary(glucose_fit_108_data$`Glucose (mg/dl)`)

# adjusted values
summary(predict(glucose_fit_108))

# plot the fit
ggplot_cosinor.lm(glucose_fit_108)
```
**Description**: fit cosinor for Ecosleep 109
```{r}
# create dataset for cosinor model for 107Ecosleep
glucose_fit_109_data <- cleaned_data_deduplicated %>%
  filter(ID == "109") %>%    # filter for 109
  mutate(
    datetime = dmy_hm(DeviceTimestamp),  #  if format TT-MM-JJJJ HH:MM
    dec.time = hour(datetime) + minute(datetime) / 60  # time as decimal hour during the day
  )

# cosinor model
glucose_fit_109 <- cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = glucose_fit_109_data, period = 24) 
summary(glucose_fit_109) 

# raw values
summary(glucose_fit_109_data$`Glucose (mg/dl)`)

# adjusted values
summary(predict(glucose_fit_109))

# plot the fit
ggplot_cosinor.lm(glucose_fit_109)
```
**Description**: fit cosinor for Ecosleep 112
```{r}
# create dataset for cosinor model for 112Ecosleep
glucose_fit_112_data <- cleaned_data_deduplicated %>%
  filter(ID == "112") %>%    # filter for 112
  mutate(
    datetime = dmy_hm(DeviceTimestamp),  #  if format TT-MM-JJJJ HH:MM
    dec.time = hour(datetime) + minute(datetime) / 60  # time as decimal hour during the day
  )

# cosinor model
glucose_fit_112 <- cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = glucose_fit_112_data, period = 24) 
summary(glucose_fit_112) 

# raw values
summary(glucose_fit_112_data$`Glucose (mg/dl)`)

# adjusted values
summary(predict(glucose_fit_112))

# plot the fit
ggplot_cosinor.lm(glucose_fit_112)
```
### Manual Cosine fit 
with datasets prepared for fit with cosinor() function (-> no hourly bins but all datapoints)
**Description**: Fit for 102
```{r}
cos_fit_102_orig <- nls(
  `Glucose (mg/dl)` ~ A * cos(2 * pi / 24 * dec.time + phi) + C,
  data = glucose_fit_102_data,
  start = list(A = 10, phi = 0, C = 100)  # start values
)

# Ergebnis anzeigen
summary(cos_fit_102_orig)

# prepare dataset for plotting
glucose_fit_102_data <- glucose_fit_102_data %>%
  mutate(Fitted = predict(cos_fit_102_orig))


ggplot(glucose_fit_102_data, aes(x = dec.time, y = `Glucose (mg/dl)`)) +
  geom_point(alpha = 0.3, color = "grey") +  # Original glucose values
  geom_line(aes(y = Fitted), color = "blue", size = 1) +  # Cosinus fit
  labs(title = "Manual Cosinus-Fit for 102 with original data",
       x = "time (decimal hours)",
       y = "Glucose (mg/dl)") +
  theme_minimal()
```
**Desciption:** Fit for 104
```{r}
cos_fit_104_orig <- nls(
  `Glucose (mg/dl)` ~ A * cos(2 * pi / 24 * dec.time + phi) + C,
  data = glucose_fit_104_data,
  start = list(A = 10, phi = 0, C = 100)  # start values
)

# Ergebnis anzeigen
summary(cos_fit_104_orig)

# prepare dataset for plotting
glucose_fit_104_data <- glucose_fit_104_data %>%
  mutate(Fitted = predict(cos_fit_104_orig))


ggplot(glucose_fit_104_data, aes(x = dec.time, y = `Glucose (mg/dl)`)) +
  geom_point(alpha = 0.3, color = "grey") +  # Original glucose values
  geom_line(aes(y = Fitted), color = "blue", size = 1) +  # Cosinus fit
  labs(title = "Manual Cosinus-Fit for 104 with original data",
       x = "time (decimal hours)",
       y = "Glucose (mg/dl)") +
  theme_minimal()
```
**Desciption:** Fit for 107
```{r}
cos_fit_107_orig <- nls(
  `Glucose (mg/dl)` ~ A * cos(2 * pi / 24 * dec.time + phi) + C,
  data = glucose_fit_107_data,
  start = list(A = 10, phi = 0, C = 100)  # start values
)

# Ergebnis anzeigen
summary(cos_fit_107_orig)

# prepare dataset for plotting
glucose_fit_107_data <- glucose_fit_107_data %>%
  mutate(Fitted = predict(cos_fit_107_orig))


ggplot(glucose_fit_107_data, aes(x = dec.time, y = `Glucose (mg/dl)`)) +
  geom_point(alpha = 0.3, color = "grey") +  # Original glucose values
  geom_line(aes(y = Fitted), color = "blue", size = 1) +  # Cosinus fit
  labs(title = "Manual Cosinus-Fit for 107 with original data",
       x = "time (decimal hours)",
       y = "Glucose (mg/dl)") +
  theme_minimal()
```
**Description:** Fit for 108
```{r}
cos_fit_108_orig <- nls(
  `Glucose (mg/dl)` ~ A * cos(2 * pi / 24 * dec.time + phi) + C,
  data = glucose_fit_108_data,
  start = list(A = 10, phi = 0, C = 100)  # start values
)

# Ergebnis anzeigen
summary(cos_fit_108_orig)

# prepare dataset for plotting
glucose_fit_108_data <- glucose_fit_108_data %>%
  mutate(Fitted = predict(cos_fit_108_orig))


ggplot(glucose_fit_108_data, aes(x = dec.time, y = `Glucose (mg/dl)`)) +
  geom_point(alpha = 0.3, color = "grey") +  # Original glucose values
  geom_line(aes(y = Fitted), color = "blue", size = 1) +  # Cosinus fit
  labs(title = "Manual Cosinus-Fit for 108 with original data",
       x = "time (decimal hours)",
       y = "Glucose (mg/dl)") +
  theme_minimal()
```
**Description:** Fit for 109
```{r}
cos_fit_109_orig <- nls(
  `Glucose (mg/dl)` ~ A * cos(2 * pi / 24 * dec.time + phi) + C,
  data = glucose_fit_109_data,
  start = list(A = 10, phi = 0, C = 100)  # start values
)

# Ergebnis anzeigen
summary(cos_fit_109_orig)

# prepare dataset for plotting
glucose_fit_109_data <- glucose_fit_109_data %>%
  mutate(Fitted = predict(cos_fit_109_orig))


ggplot(glucose_fit_109_data, aes(x = dec.time, y = `Glucose (mg/dl)`)) +
  geom_point(alpha = 0.3, color = "grey") +  # Original glucose values
  geom_line(aes(y = Fitted), color = "blue", size = 1) +  # Cosinus fit
  labs(title = "Manual Cosinus-Fit for 109 with original data",
       x = "time (decimal hours)",
       y = "Glucose (mg/dl)") +
  theme_minimal()
```
**Description:** Fit for 112
```{r}
cos_fit_112_orig <- nls(
  `Glucose (mg/dl)` ~ A * cos(2 * pi / 24 * dec.time + phi) + C,
  data = glucose_fit_112_data,
  start = list(A = 10, phi = 0, C = 100)  # start values
)

# Ergebnis anzeigen
summary(cos_fit_112_orig)

# prepare dataset for plotting
glucose_fit_112_data <- glucose_fit_112_data %>%
  mutate(Fitted = predict(cos_fit_112_orig))


ggplot(glucose_fit_112_data, aes(x = dec.time, y = `Glucose (mg/dl)`)) +
  geom_point(alpha = 0.3, color = "grey") +  # Original glucose values
  geom_line(aes(y = Fitted), color = "blue", size = 1) +  # Cosinus fit
  labs(title = "Manual Cosinus-Fit for 112 with original data",
       x = "time (decimal hours)",
       y = "Glucose (mg/dl)") +
  theme_minimal()
```
### Comparison of outputs of the different fits
```{r}
summary(cos_fit_102)
summary(glucose_fit_102)
summary(cos_fit_102_orig)
```

```{r}
summary(cos_fit_104)
summary(glucose_fit_104)
summary(cos_fit_104_orig)
```

```{r}
summary(cos_fit_107)
summary(glucose_fit_107)
summary(cos_fit_107_orig)
```

```{r}
summary(cos_fit_108)
summary(glucose_fit_108)
summary(cos_fit_108_orig)
```

```{r}
summary(cos_fit_109)
summary(glucose_fit_109)
summary(cos_fit_109_orig)
```

```{r}
summary(cos_fit_112)
summary(glucose_fit_112)
summary(cos_fit_112_orig)
```
### Trouble Shooting: Cosine Fit
```{r}
# 1. Zeitreihe erzeugen
datetime <- seq(
  from = as.POSIXct("2025-01-01 00:00:00"),
  to = as.POSIXct("2025-01-07 23:30:00"),
  by = "30 min"
)

# 2. Dezimalzeit für 24h-Periode
dec.time <- as.numeric(format(datetime, "%H")) + as.numeric(format(datetime, "%M")) / 60

# 3. Cosinus mit 24h-Periode, Maximum um 18 Uhr
mesor <- 100
amplitude <- 20
phase_shift <- pi/2  # Maximum bei 18 Uhr

glucose <- mesor + amplitude * cos(2 * pi * dec.time / 24 + phase_shift)

# 4. In DataFrame
synthetic_24h <- data.frame(datetime, dec.time, glucose)

# 5. Plot
ggplot(synthetic_24h, aes(x = datetime, y = glucose)) +
  geom_line(color = "darkorange3") +
  labs(
    title = "Synthetische Glukosekurve (Min bei 6 Uhr, Max bei 18 Uhr)",
    y = "Glukose", x = "Zeit"
  ) +
  theme_minimal()



# 5. Cosinor-Komponenten
synthetic_24h <- synthetic_24h %>%
  mutate(
    cos_part = cos(2 * pi * dec.time / 24),
    sin_part = sin(2 * pi * dec.time / 24)
  )



### ----- Manueller lm-Fit -----
fit_lm <- lm(glucose ~ cos_part + sin_part, data = synthetic_24h)
coefs_lm <- coef(fit_lm)

intercept_l <- coefs_lm["(Intercept)"]
beta <- coefs_lm["cos_part"]
gamma <- coefs_lm["sin_part"]

amp_l <- sqrt(beta^2 + gamma^2)
acr_rad_l <- atan2(gamma, beta) # HIER: normalerweise atan2(-gamma, beta), wenn man das minus rausnimmt, macht der Output Sinn
acr_hr_l <- (acr_rad_l * 24 / (2 * pi)) %% 24
max_time_l <- acr_hr_l
min_time_l <- (acr_hr_l + 12) %% 24

### ----- cosinor.lm-Fit -----
fit_cos <- cosinor.lm(glucose ~ time(dec.time), data = synthetic_24h, period = 24)
coefs_cos <- coef(fit_cos, transformed = TRUE)

intercept_cos   <- coefs_cos["(Intercept)"]
amp_cos         <- coefs_cos["amp"]
acr_rad_cos <- coefs_cos["acr"]
acr_hr_cos <- (acr_rad_cos * 24) / (2 * pi)
max_time_cos    <- acr_hr_cos %% 24
min_time_cos    <- (acr_hr_cos + 12) %% 24


### ----- Zusammenfassung in DataFrame -----
summary_df <- data.frame(
  Window_Start      = as.POSIXct("2025-01-01 00:00:00"),
  
  # manuelles Modell
  Intercept_lm      = intercept_l,
  Amp_lm            = amp_l,
  Acrophase_Rad_lm  = acr_rad_l,
  Acrophase_Hours_lm= acr_hr_l,
  MaxTime_Hours_lm  = max_time_l,
  MinTime_Hours_lm  = min_time_l,
  
  # cosinor.lm Modell
  Intercept_cos     = intercept_cos,
  Amp_cos           = amp_cos,
  Acrophase_Rad_cos = acr_rad_cos,
  Acrophase_Hours_cos = acr_hr_cos,
  MaxTime_Hours_cos = max_time_cos,
  MinTime_Hours_cos = min_time_cos
)

######################## das ganze für den Datensatz der ID 102 ausprobieren

# Daten für Patient ID 102 vorbereiten
glucose_fit_102_data <- cleaned_data_deduplicated %>%
  filter(ID == "102") %>% 
  mutate(
    datetime = dmy_hm(DeviceTimestamp), 
    dec.time = hour(datetime) + minute(datetime) / 60
  )

# 5. Cosinor-Komponenten
glucose_fit_102_data <- glucose_fit_102_data %>%
  mutate(
    cos_part = cos(2 * pi * dec.time / 24),
    sin_part = sin(2 * pi * dec.time / 24)
  )

### ----- Manueller lm-Fit -----
fit_lm <- lm(`Glucose (mg/dl)` ~ cos_part + sin_part, data = glucose_fit_102_data)
coefs_lm <- coef(fit_lm)

intercept_l <- coefs_lm["(Intercept)"]
beta <- coefs_lm["cos_part"]
gamma <- coefs_lm["sin_part"]

amp_l <- sqrt(beta^2 + gamma^2)
acr_rad_l <- atan2(gamma, beta) # HIER: normalerweise atan2(-gamma, beta)
acr_hr_l <- (acr_rad_l * 24 / (2 * pi)) %% 24
max_time_l <- acr_hr_l
min_time_l <- (acr_hr_l + 12) %% 24

### ----- cosinor.lm-Fit -----
fit_cos <- cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = glucose_fit_102_data, period = 24)
coefs_cos <- coef(fit_cos, transformed = TRUE)

intercept_cos <- coefs_cos["(Intercept)"]
amp_cos <- coefs_cos["amp"]
acr_rad_cos <- coefs_cos["acr"]
acr_hr_cos <- (acr_rad_cos * 24 / (2 * pi)) %% 24  # Konsistent: %% 24 hier anwenden
max_time_cos <- acr_hr_cos
min_time_cos <- (acr_hr_cos + 12) %% 24

### ----- Zusammenfassung in DataFrame -----
summary_df_102 <- data.frame(
  Patient_ID = "102",
  Window_Start = min(glucose_fit_102_data$datetime, na.rm = TRUE),
  Window_End = max(glucose_fit_102_data$datetime, na.rm = TRUE),
  N_Observations = nrow(glucose_fit_102_data),
  
  # manuelles Modell
  Intercept_lm = intercept_l,
  Amp_lm = amp_l,
  Acrophase_Rad_lm = acr_rad_l,
  Acrophase_Hours_lm = acr_hr_l,
  MaxTime_Hours_lm = max_time_l,
  MinTime_Hours_lm = min_time_l,
  
  # cosinor.lm Modell
  Intercept_cos = intercept_cos,
  Amp_cos = amp_cos,
  Acrophase_Rad_cos = acr_rad_cos,
  Acrophase_Hours_cos = acr_hr_cos,
  MaxTime_Hours_cos = max_time_cos,
  MinTime_Hours_cos = min_time_cos
)
```
### Cosine fit with lm()
**Description:** Fit over whole dataset
```{r}
# Step 1: Prepare datetime and Cosinor components
glucose_fit_data <- cleaned_data_deduplicated %>%
  mutate(
    datetime = dmy_hm(DeviceTimestamp, tz = "Europe/Berlin"), 
    dec.time = hour(datetime) + minute(datetime) / 60,
    cos_part = cos(2 * pi * dec.time / 24),
    sin_part = sin(2 * pi * dec.time / 24)
  )

# Step 2: Initialize list to collect data with predictions
all_predictions <- list()
summary_list <- list()
ids <- unique(glucose_fit_data$ID)

# Step 3: Loop through each ID
for (id in ids) {
  df <- glucose_fit_data %>% filter(ID == id)
  
  # Fit Cosinor model
  fit_lm <- lm(`Glucose (mg/dl)` ~ cos_part + sin_part, data = df)
  df$predicted_glucose <- predict(fit_lm)
  
  # Save predicted data
  all_predictions[[length(all_predictions) + 1]] <- df
  
  # Save summary (optional)
  coefs <- coef(fit_lm)
  intercept <- coefs["(Intercept)"]
  beta <- coefs["cos_part"]
  gamma <- coefs["sin_part"]
  
  amp <- sqrt(beta^2 + gamma^2)
  acr_rad <- atan2(gamma, beta)
  acr_hr <- (acr_rad * 24 / (2 * pi)) %% 24
  max_time <- acr_hr
  min_time <- (acr_hr + 12) %% 24
  max_value <- intercept + amp
  min_value <- intercept - amp
  
  summary_list[[length(summary_list) + 1]] <- data.frame(
    Patient_ID = id,
    Window_Start = min(df$datetime, na.rm = TRUE),
    Window_End = max(df$datetime, na.rm = TRUE),
    N_Observations = nrow(df),
    Intercept_lm = intercept,
    Amp_lm = amp,
    Acrophase_Rad_lm = acr_rad,
    Acrophase_Hours_lm = acr_hr,
    MaxTime_Hours_lm = max_time,
    MinTime_Hours_lm = min_time,
    MaxValue_lm = max_value,
    MinValue_lm = min_value
  )
}

# Step 4: Combine data
cosinor_summary <- do.call(rbind, summary_list)
plot_data <- bind_rows(all_predictions)
plot_data$ID <- as.factor(plot_data$ID)  # for facetting

# Step 5: Plot with facets
ggplot(plot_data, aes(x = dec.time)) +
  geom_point(aes(y = `Glucose (mg/dl)`), color = "blue", alpha = 0.4, size = 1.2) +
  geom_line(aes(y = predicted_glucose), color = "red", size = 1) +
  facet_wrap(~ ID, scales = "free_y") +
  labs(
    title = "Cosinor Fits for All Patients",
    x = "Time of Day (decimal hours)",
    y = "Glucose (mg/dl)"
  ) +
  theme_minimal() +
  theme(strip.text = element_text(face = "bold"))

```
**Description:** Fit for every day
```{r}
# Step 1: Prepare datetime and Cosinor components
glucose_fit_data <- cleaned_data_deduplicated %>%
  mutate(
    datetime = dmy_hm(DeviceTimestamp, tz = "Europe/Berlin"), 
    date = as.Date(datetime),
    dec.time = hour(datetime) + minute(datetime) / 60,
    cos_part = cos(2 * pi * dec.time / 24),
    sin_part = sin(2 * pi * dec.time / 24)
  )

# Step 2: Initialize collectors
all_predictions <- list()
summary_list <- list()

# Step 3: Loop over each ID and Date
ids <- unique(glucose_fit_data$ID)

for (id in ids) {
  df_id <- glucose_fit_data %>% filter(ID == id)
  dates <- unique(df_id$date)
  
  for (d in dates) {
    df_day <- df_id %>% filter(date == d)
    
    # Only fit if enough data
    if (nrow(df_day) < 3 || all(is.na(df_day$`Glucose (mg/dl)`))) next
    
    fit <- lm(`Glucose (mg/dl)` ~ cos_part + sin_part, data = df_day)
    df_day$predicted_glucose <- predict(fit)
    
    # Store prediction
    all_predictions[[length(all_predictions) + 1]] <- df_day
    
    # Cosinor summary
    coefs <- coef(fit)
    intercept <- coefs["(Intercept)"]
    beta <- coefs["cos_part"]
    gamma <- coefs["sin_part"]
    
    amp <- sqrt(beta^2 + gamma^2)
    acr_rad <- atan2(gamma, beta)
    acr_hr <- (acr_rad * 24 / (2 * pi)) %% 24
    
    summary_list[[length(summary_list) + 1]] <- data.frame(
      Patient_ID = id,
      Date = d,
      Intercept = intercept,
      Amplitude = amp,
      Acrophase_Rad = acr_rad,
      Acrophase_Hours = acr_hr,
      N_Obs = nrow(df_day)
    )
  }
}

# Step 4: Combine results
cosinor_daily_summary <- do.call(rbind, summary_list)
cosinor_daily_predictions <- bind_rows(all_predictions)
```
**Description:** Check fit with 14-day plot
```{r}
## ID 102
# Filter for ID 102 and select first 14 dates
df_102_first14 <- cosinor_daily_predictions %>%
  filter(ID == "102") %>%
  mutate(date = as.Date(datetime)) %>%
  filter(date %in% sort(unique(date))[1:14])  # keep only first 14 days

# Plot with facets
ggplot(df_102_first14, aes(x = datetime)) +
  geom_point(aes(y = `Glucose (mg/dl)`), alpha = 0.4, size = 1.2, color = "blue") +
  geom_line(aes(y = predicted_glucose), color = "red", size = 1) +
  labs(
    title = "Daily Cosinor Fits for ID 102 – First 14 Days",
    x = "Time of Day",
    y = "Glucose (mg/dl)"
  ) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "3 hours") +
  theme_minimal(base_size = 12)+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1))

## ID 104
# Filter for ID 104 and select first 14 dates
df_104_first14 <- cosinor_daily_predictions %>%
  filter(ID == "104") %>%
  mutate(date = as.Date(datetime)) %>%
  filter(date %in% sort(unique(date))[1:14])  # keep only first 14 days

# Plot with facets
ggplot(df_104_first14, aes(x = datetime)) +
  geom_point(aes(y = `Glucose (mg/dl)`), alpha = 0.4, size = 1.2, color = "blue") +
  geom_line(aes(y = predicted_glucose), color = "red", size = 1) +
  labs(
    title = "Daily Cosinor Fits for ID 104 – First 14 Days",
    x = "Time of Day",
    y = "Glucose (mg/dl)"
  ) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "3 hours") +
  theme_minimal(base_size = 12)+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1))

## ID 107
# Filter for ID 107 and select first 14 dates
df_107_first14 <- cosinor_daily_predictions %>%
  filter(ID == "107") %>%
  mutate(date = as.Date(datetime)) %>%
  filter(date %in% sort(unique(date))[1:14])  # keep only first 14 days

# Plot with facets
ggplot(df_107_first14, aes(x = datetime)) +
  geom_point(aes(y = `Glucose (mg/dl)`), alpha = 0.4, size = 1.2, color = "blue") +
  geom_line(aes(y = predicted_glucose), color = "red", size = 1) +
  labs(
    title = "Daily Cosinor Fits for ID 107 – First 14 Days",
    x = "Time of Day",
    y = "Glucose (mg/dl)"
  ) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "3 hours") +
  theme_minimal(base_size = 12)+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1))

## ID 108
# Filter for ID 108 and select first 14 dates
df_108_first14 <- cosinor_daily_predictions %>%
  filter(ID == "108") %>%
  mutate(date = as.Date(datetime)) %>%
  filter(date %in% sort(unique(date))[1:14])  # keep only first 14 days

# Plot with facets
ggplot(df_108_first14, aes(x = datetime)) +
  geom_point(aes(y = `Glucose (mg/dl)`), alpha = 0.4, size = 1.2, color = "blue") +
  geom_line(aes(y = predicted_glucose), color = "red", size = 1) +
  labs(
    title = "Daily Cosinor Fits for ID 108 – First 14 Days",
    x = "Time of Day",
    y = "Glucose (mg/dl)"
  ) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "3 hours") +
  theme_minimal(base_size = 12)+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1))

## ID 109
# Filter for ID 109 and select first 14 dates
df_109_first14 <- cosinor_daily_predictions %>%
  filter(ID == "109") %>%
  mutate(date = as.Date(datetime)) %>%
  filter(date %in% sort(unique(date))[1:14])  # keep only first 14 days

# Plot with facets
ggplot(df_109_first14, aes(x = datetime)) +
  geom_point(aes(y = `Glucose (mg/dl)`), alpha = 0.4, size = 1.2, color = "blue") +
  geom_line(aes(y = predicted_glucose), color = "red", size = 1) +
  labs(
    title = "Daily Cosinor Fits for ID 109 – First 14 Days",
    x = "Time of Day",
    y = "Glucose (mg/dl)"
  ) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "3 hours") +
  theme_minimal(base_size = 12)+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1))

## ID 112
# Filter for ID 112 and select second 14 dates
df_112_first14 <- cosinor_daily_predictions %>%
  filter(ID == "112") %>%
  mutate(date = as.Date(datetime)) %>%
  filter(date %in% sort(unique(date))[15:28])  # keep only second 14 days

# Plot with facets
ggplot(df_112_first14, aes(x = datetime)) +
  geom_point(aes(y = `Glucose (mg/dl)`), alpha = 0.4, size = 1.2, color = "blue") +
  geom_line(aes(y = predicted_glucose), color = "red", size = 1) +
  labs(
    title = "Daily Cosinor Fits for ID 112 – Second 14 Days",
    x = "Time of Day",
    y = "Glucose (mg/dl)"
  ) +
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "3 hours") +
  theme_minimal(base_size = 12)+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1))

```

### Moving window
#### Moving Window with cosinor.lm()
**Description:** Cos for 102: Moving window for 102 

```{r}
  # Storage for results
  moving_window_102 <- data.frame(
    Window_Start = as.POSIXct(character()),
    Amp = numeric(),
    Acrophase_Rad = numeric(),
    Acrophase_Raw = numeric(),
    Acrophase_Raw_Hours = numeric(),
    Max_Time_Hours = numeric(),
    Min_Time_Hours = numeric(),
    Intercept = numeric(),
    stringsAsFactors = FALSE
  )
  
  # Time boundaries
  start_time_mv_102 <- min(glucose_fit_102_data$datetime)
  end_time_mv_102 <- max(glucose_fit_102_data$datetime)
  
  # Window setup
  window_length <- days(3)
  step_size <- days(1)
  current_start_102 <- start_time_mv_102
  
  while (current_start_102 + window_length <= end_time_mv_102) {
    
    current_end_102 <- current_start_102 + window_length
    
    # Filter window
    window_data_102 <- glucose_fit_102_data %>%
      filter(datetime >= current_start_102 & datetime < current_end_102)
    
    # Skip small windows
    if (nrow(window_data_102) < 100) {
      current_start_102 <- current_start_102 + step_size
      next
    }
    
    # Try fitting model
    fit_102 <- tryCatch({
      cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = window_data_102, period = 24)
    }, error = function(e) NA)
    
    # Proceed only if fit succeeded
    if (inherits(fit_102, "cosinor.lm")) {
      
      coefs_102 <- coef(fit_102, transformed = TRUE)
      
      # Safe extraction
      if (is.matrix(coefs_102)) {
        amp_102 <- coefs_102["amp", "estimate"]
        acr_102 <- coefs_102["acr", "estimate"]
        intercept_102 <- coefs_102["(Intercept)", "estimate"]
      } else if (is.vector(coefs_102)) {
        amp_102 <- coefs_102["amp"]
        acr_102 <- coefs_102["acr"]
        intercept_102 <- coefs_102["(Intercept)"]
      } else {
        current_start_102 <- current_start_102 + step_size
        next
      }
      
      
   # Raw acrophase in hours
    acrophase_raw_102 <- (acr_102 * 24) / (2 * pi)
    
    # Calculate max time (adjusted by 12h if amplitude is negative)
    max_time_102 <- ((acrophase_raw_102 + ifelse(amp_102 < 0, 12, 0)) + 24) %% 24
    min_time_102 <- (max_time_102 + 12) %% 24
    
    # Store results
    moving_window_102 <- rbind(moving_window_102, data.frame(
      Window_Start = current_start_102,
      Amp = amp_102,
      Acrophase_Rad = acr_102,
      Acrophase_Raw = acrophase_raw_102,
      Acrophase_Raw_Hours = (acrophase_raw_102 + 24) %% 24,
      Max_Time_Hours = max_time_102,
      Min_Time_Hours = min_time_102,
      Intercept = intercept_102
    ))
  }
  
  # Move to next window
  current_start_102 <- current_start_102 + step_size
}
```
**Description:** Cos for 102: Plot
```{r}
ggplot(moving_window_102, aes(x = Window_Start)) +
  geom_line(aes(y = Max_Time_Hours, color = "Maximum")) +
  geom_line(aes(y = Min_Time_Hours, color = "Minimum")) +
  geom_point(aes(y = Max_Time_Hours, color = "Maximum")) +
  geom_point(aes(y = Min_Time_Hours, color = "Minimum")) +
  scale_color_manual(values = c("Maximum" = "red", "Minimum" = "blue")) +
  scale_y_continuous(breaks = seq(0, 24, 2), limits = c(0, 24)) +
  labs(
    title = "Diurnal Pattern of Maximum and Minimum (Glucose Cosinor)",
    x = "Window Start Time",
    y = "Time of Day (Hours)",
    color = "Time Point"
  ) +
  theme_minimal()
```
**Description:** Moving Window Cos for 102: min. 400 datapoints are needed to calculate the cos + using package cosinor.lm()
```{r}
# Empty dataframe to store results
moving_window_102 <- data.frame(
  Window_Start = as.POSIXct(character()),
  Amp = numeric(),
  Acrophase_Rad = numeric(),
  Acrophase_Raw = numeric(),
  Acrophase_Raw_Hours = numeric(),
  Max_Time_Hours = numeric(),
  Min_Time_Hours = numeric(),
  Intercept = numeric(),
  stringsAsFactors = FALSE
)

# Define time boundaries
start_time_mv_102 <- min(glucose_fit_102_data$datetime)
end_time_mv_102 <- max(glucose_fit_102_data$datetime)

# Window and step sizes
window_length <- days(3)
step_size <- days(1)
current_start_102 <- start_time_mv_102

# Sliding window analysis
while (current_start_102 + window_length <= end_time_mv_102) {
  
  current_end_102 <- current_start_102 + window_length
  
  # Filter data within window
  window_data_102 <- glucose_fit_102_data %>%
    filter(datetime >= current_start_102 & datetime < current_end_102)
  
  # Skip windows with too few data points
  if (nrow(window_data_102) < 400) {
    current_start_102 <- current_start_102 + step_size
    next
  }
  
  # Fit cosinor model
  fit_102 <- tryCatch({
    cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = window_data_102, period = 24)
  }, error = function(e) NA)
  
  if (inherits(fit_102, "cosinor.lm")) {
    
    coefs_102 <- coef(fit_102, transformed = TRUE)
    
    # Extract coefficients
    if (is.matrix(coefs_102)) {
      amp_102 <- coefs_102["amp", "estimate"]
      acr_102 <- coefs_102["acr", "estimate"]
      intercept_102 <- coefs_102["(Intercept)", "estimate"]
    } else if (is.vector(coefs_102)) {
      amp_102 <- coefs_102["amp"]
      acr_102 <- coefs_102["acr"]
      intercept_102 <- coefs_102["(Intercept)"]
    } else {
      current_start_102 <- current_start_102 + step_size
      next
    }
    
    # Raw acrophase in hours
    acrophase_raw_102 <- (acr_102 * 24) / (2 * pi)
    acrophase_norm_102 <- (acrophase_raw_102 + 24) %% 24
    
    # Max and min time depending on amplitude sign
    if (amp_102 >= 0) {
      max_time_102 <- acrophase_norm_102
      min_time_102 <- (acrophase_norm_102 + 12) %% 24
    } else {
      min_time_102 <- acrophase_norm_102
      max_time_102 <- (acrophase_norm_102 + 12) %% 24
    }
     # Ensure max > 12 and min < 12 (if desired visual convention)
    if (max_time_102 < 12) {
      temp_102 <- max_time_102
      max_time_102 <- min_time_102
      min_time_102 <- temp_102
    }
    
    
    # Store results
    moving_window_102 <- rbind(moving_window_102, data.frame(
      Window_Start = current_start_102,
      Amp = amp_102,
      Acrophase_Rad = acr_102,
      Acrophase_Raw = acrophase_raw_102,
      Acrophase_Raw_Hours = acrophase_norm_102,
      Max_Time_Hours = max_time_102,
      Min_Time_Hours = min_time_102,
      Intercept = intercept_102
    ))
  }
  
  # Move to next window
  current_start_102 <- current_start_102 + step_size
}
```
**Description:** Moving Window Cos for 102: Plot
```{r}
ggplot(moving_window_102, aes(x = Window_Start)) +
  geom_line(aes(y = Max_Time_Hours, color = "Maximum"), size = 0.5) +
  geom_line(aes(y = Min_Time_Hours, color = "Minimum"), size = 0.5) +
  geom_point(aes(y = Max_Time_Hours, color = "Maximum"), size = 1) +
  geom_point(aes(y = Min_Time_Hours, color = "Minimum"), size = 1) +
  scale_color_manual(
    name = "Time Point",
    values = c("Maximum" = "red", "Minimum" = "blue")
  ) +
  scale_y_continuous(
    breaks = seq(0, 24, 2),
    limits = c(0, 24),
    expand = c(0, 0)
  ) +
  labs(
    title = "Diurnal Timing of Maximum and Minimum (Glucose Cosinor)",
    x = "Window Start Time",
    y = "Time of Day (Hours)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```
**Description:** Moving Window Cos for 102 with lm
```{r}
 # Empty Dataframe to store results
 moving_window_102_l <- data.frame(
   Window_Start = as.POSIXct(character()),
   Amp = numeric(),
   Acrophase_Rad = numeric(),
   Acrophase_Raw = numeric(),
   Acrophase_Raw_Hours = numeric(),
   Max_Time_Hours = numeric(),
   Min_Time_Hours = numeric(),
   Intercept = numeric(),
   stringsAsFactors = FALSE
 )
 
 # Defining time boundaries
 start_time_mv_102 <- min(glucose_fit_102_data$datetime)
 end_time_mv_102   <- max(glucose_fit_102_data$datetime)
 
 # window and step sizes
 window_length <- days(3)
 step_size <- days(1)
 current_start_102 <- start_time_mv_102
 
 # Sliding window loop
 while (current_start_102 + window_length <= end_time_mv_102) {
   
   current_end_102 <- current_start_102 + window_length
   
   # Filter Data within window
   window_data_102_l <- glucose_fit_102_data %>%
     filter(datetime >= current_start_102 & datetime < current_end_102)
   
   # Skip windows with too few data points
   if (nrow(window_data_102_l) < 400) {
     current_start_102 <- current_start_102 + step_size
     next
   }
   
   # calculate cosinus components
   dec_time_102_l <- window_data_102_l$dec.time
   window_data_102_l$cos_part <- cos(2 * pi * dec_time_102_l / 24)
   window_data_102_l$sin_part <- sin(2 * pi * dec_time_102_l / 24)
   
   # fit with linear regression
   fit_test_102_l <- tryCatch({
     lm(`Glucose (mg/dl)` ~ cos_part + sin_part, data = window_data_102_l)
   }, error = function(e) NA)
   
   # test
   if (!inherits(fit_test_102_l, "lm")) {
     current_start_102 <- current_start_102 + step_size
     next
   }
   
   coefs <- coef(fit_test_102_l)
   
   # skip if NA in relevant coefficents
   if (any(is.na(coefs[c("(Intercept)", "cos_part", "sin_part")]))) {
     current_start_102 <- current_start_102 + step_size
     next
   }
   
   # extract coefficients
   intercept_102_l <- coefs["(Intercept)"]
   beta_102_l      <- coefs["cos_part"]
   gamma_102_l     <- coefs["sin_part"]
   
   # amolitude
   amp_102_l <- sqrt(beta_102_l^2 + gamma_102_l^2)
   
   # Acrophase (radiant)
   acr_rad_102_l <- atan2(gamma_102_l, beta_102_l)  # without minus
   
   # Acrophase (hours)
   acrophase_raw_102_l <- (acr_rad_102_l * 24) / (2 * pi)
   acrophase_norm_102_l <- (acrophase_raw_102_l + 24) %% 24
   
   # max and min time
   max_time_102_l <- acrophase_norm_102_l
   min_time_102_l <- (acrophase_norm_102_l + 12) %% 24
   
   # store results
   moving_window_102_l <- rbind(moving_window_102_l, data.frame(
     Window_Start = current_start_102,
     Amp = amp_102_l,
     Acrophase_Rad = acr_rad_102_l,
     Acrophase_Raw = acrophase_raw_102_l,
     Acrophase_Raw_Hours = acrophase_norm_102_l,
     Max_Time_Hours = max_time_102_l,
     Min_Time_Hours = min_time_102_l,
     Intercept = intercept_102_l
   ))
   
   # next window
   current_start_102 <- current_start_102 + step_size
 }
```
**Description:** Data Set for Comparison of cosinor.lm() and lm() method
```{r}
 # Leerer DataFrame zur Speicherung
moving_window_comparison <- data.frame(
  Window_Start = as.POSIXct(character()),
  Amp_C = numeric(),
  Amp_L = numeric(),
  Acrophase_Rad_C = numeric(),
  Acrophase_Rad_L = numeric(),
  Intercept_C = numeric(),
  Intercept_L = numeric(),
  stringsAsFactors = FALSE
)

# Zeitgrenzen
start_time_mv_102 <- min(glucose_fit_102_data$datetime)
end_time_mv_102   <- max(glucose_fit_102_data$datetime)

# Fenster und Schritt
window_length <- days(3)
step_size <- days(1)
current_start_102 <- start_time_mv_102

# Sliding-Window
while (current_start_102 + window_length <= end_time_mv_102) {
  
  current_end_102 <- current_start_102 + window_length
  
  # Daten filtern
  window_data_102_comparison <- glucose_fit_102_data %>%
    filter(datetime >= current_start_102 & datetime < current_end_102)
  
  if (nrow(window_data_102_comparison) < 400) {
    current_start_102 <- current_start_102 + step_size
    next
  }
  
  # Cosinor-Teile berechnen
  dec_time <- window_data_102_comparison$dec.time
  window_data_102_comparison$cos_part <- cos(2 * pi * dec_time / 24)
  window_data_102_comparison$sin_part <- sin(2 * pi * dec_time / 24)
  
  # Lineares Modell
  fit_test <- tryCatch({
    lm(`Glucose (mg/dl)` ~ cos_part + sin_part, data = window_data_102_comparison)
  }, error = function(e) NA)
  
  if (!inherits(fit_test, "lm")) {
    current_start_102 <- current_start_102 + step_size
    next
  }
  
  coefs <- coef(fit_test)
  if (any(is.na(coefs[c("(Intercept)", "cos_part", "sin_part")]))) {
    current_start_102 <- current_start_102 + step_size
    next
  }
  
  intercept_L <- coefs["(Intercept)"]
  beta_102    <- coefs["cos_part"]
  gamma_102   <- coefs["sin_part"]
  
  amp_L      <- sqrt(beta_102^2 + gamma_102^2)
  acr_L_rad  <- atan2(gamma_102, beta_102)
  
  # Cosinor-Paketmodell
  fit_102 <- tryCatch({
    cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), 
               data = window_data_102_comparison, 
               period = 24)
  }, error = function(e) NA)
  
  if (inherits(fit_102, "cosinor.lm")) {
    
    coefs_102 <- coef(fit_102, transformed = TRUE)
    
    if (is.matrix(coefs_102)) {
      amp_C      <- coefs_102["amp", "estimate"]
      acr_C_rad  <- coefs_102["acr", "estimate"]
      intercept_C <- coefs_102["(Intercept)", "estimate"]
    } else if (is.vector(coefs_102)) {
      amp_C      <- coefs_102["amp"]
      acr_C_rad  <- coefs_102["acr"]
      intercept_C <- coefs_102["(Intercept)"]
    } else {
      current_start_102 <- current_start_102 + step_size
      next
    }
    
    # Ergebnisse speichern
    moving_window_comparison <- rbind(moving_window_comparison, data.frame(
      Window_Start = current_start_102,
      Amp_C = amp_C,
      Amp_L = amp_L,
      Acrophase_Rad_C = acr_C_rad,
      Acrophase_Rad_L = acr_L_rad,
      Intercept_C = intercept_C,
      Intercept_L = intercept_L
    ))
  }
  
  current_start_102 <- current_start_102 + step_size
}
 
```
**Description:** Moving Window Cos for 104
```{r}
# Empty dataframe to store results
moving_window_104 <- data.frame(
  Window_Start = as.POSIXct(character()),
  Amp = numeric(),
  Acrophase_Rad = numeric(),
  Acrophase_Raw = numeric(),
  Acrophase_Raw_Hours = numeric(),
  Max_Time_Hours = numeric(),
  Min_Time_Hours = numeric(),
  Intercept = numeric(),
  stringsAsFactors = FALSE
)

# Define time boundaries
start_time_mv_104 <- min(glucose_fit_104_data$datetime)
end_time_mv_104 <- max(glucose_fit_104_data$datetime)

# Window and step sizes
window_length <- days(3)
step_size <- days(1)
current_start_104 <- start_time_mv_104

# Sliding window analysis
while (current_start_104 + window_length <= end_time_mv_104) {
  
  current_end_104 <- current_start_104 + window_length
  
  # Filter data within window
  window_data_104 <- glucose_fit_104_data %>%
    filter(datetime >= current_start_104 & datetime < current_end_104)
  
  # Skip windows with too few data points
  if (nrow(window_data_104) < 400) {
    current_start_104 <- current_start_104 + step_size
    next
  }
  
  # Fit cosinor model
  fit_104 <- tryCatch({
    cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = window_data_104, period = 24)
  }, error = function(e) NA)
  
  if (inherits(fit_104, "cosinor.lm")) {
    
    coefs_104 <- coef(fit_104, transformed = TRUE)
    
    # Extract coefficients
    if (is.matrix(coefs_104)) {
      amp_104 <- coefs_104["amp", "estimate"]
      acr_104 <- coefs_104["acr", "estimate"]
      intercept_104 <- coefs_104["(Intercept)", "estimate"]
    } else if (is.vector(coefs_104)) {
      amp_104 <- coefs_104["amp"]
      acr_104 <- coefs_104["acr"]
      intercept_104 <- coefs_104["(Intercept)"]
    } else {
      current_start_104 <- current_start_104 + step_size
      next
    }
    
    # Raw acrophase in hours
    acrophase_raw_104 <- (acr_104 * 24) / (2 * pi)
    acrophase_norm_104 <- (acrophase_raw_104 + 24) %% 24
    
    # Max and min time depending on amplitude sign
    if (amp_104 >= 0) {
      max_time_104 <- acrophase_norm_104
      min_time_104 <- (acrophase_norm_104 + 12) %% 24
    } else {
      min_time_104 <- acrophase_norm_104
      max_time_104 <- (acrophase_norm_104 + 12) %% 24
    }
    
    # Ensure max > 12 and min < 12 (if desired visual convention)
    if (max_time_104 < 12) {
      temp_104 <- max_time_104
      max_time_104 <- min_time_104
      min_time_104 <- temp_104
    }
    
    # Store results
    moving_window_104 <- rbind(moving_window_104, data.frame(
      Window_Start = current_start_104,
      Amp = amp_104,
      Acrophase_Rad = acr_104,
      Acrophase_Raw = acrophase_raw_104,
      Acrophase_Raw_Hours = acrophase_norm_104,
      Max_Time_Hours = max_time_104,
      Min_Time_Hours = min_time_104,
      Intercept = intercept_104
    ))
  }
  
  # Move to next window
  current_start_104 <- current_start_104 + step_size
}
```
**Description:** Moving Window Cos for 104: Plot
```{r}
ggplot(moving_window_104, aes(x = Window_Start)) +
  geom_line(aes(y = Max_Time_Hours, color = "Maximum"), size = 0.5) +
  geom_line(aes(y = Min_Time_Hours, color = "Minimum"), size = 0.5) +
  geom_point(aes(y = Max_Time_Hours, color = "Maximum"), size = 1) +
  geom_point(aes(y = Min_Time_Hours, color = "Minimum"), size = 1) +
  scale_color_manual(
    name = "Time Point",
    values = c("Maximum" = "red", "Minimum" = "blue")
  ) +
  scale_y_continuous(
    breaks = seq(0, 24, 2),
    limits = c(0, 24),
    expand = c(0, 0)
  ) +
  labs(
    title = "Diurnal Timing of Maximum and Minimum (Glucose Cosinor)",
    x = "Window Start Time",
    y = "Time of Day (Hours)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```
**Description:** Moving Window Cos for 107
```{r}
# Empty dataframe to store results
moving_window_107 <- data.frame(
  Window_Start = as.POSIXct(character()),
  Amp = numeric(),
  Acrophase_Rad = numeric(),
  Acrophase_Raw = numeric(),
  Acrophase_Raw_Hours = numeric(),
  Max_Time_Hours = numeric(),
  Min_Time_Hours = numeric(),
  Intercept = numeric(),
  stringsAsFactors = FALSE
)

# Define time boundaries
start_time_mv_107 <- min(glucose_fit_107_data$datetime)
end_time_mv_107 <- max(glucose_fit_107_data$datetime)

# Window and step sizes
window_length <- days(3)
step_size <- days(1)
current_start_107 <- start_time_mv_107

# Sliding window analysis
while (current_start_107 + window_length <= end_time_mv_107) {
  
  current_end_107 <- current_start_107 + window_length
  
  # Filter data within window
  window_data_107 <- glucose_fit_107_data %>%
    filter(datetime >= current_start_107 & datetime < current_end_107)
  
  # Skip windows with too few data points
  if (nrow(window_data_107) < 400) {
    current_start_107 <- current_start_107 + step_size
    next
  }
  
  # Fit cosinor model
  fit_107 <- tryCatch({
    cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = window_data_107, period = 24)
  }, error = function(e) NA)
  
  if (inherits(fit_107, "cosinor.lm")) {
    
    coefs_107 <- coef(fit_107, transformed = TRUE)
    
    # Extract coefficients
    if (is.matrix(coefs_107)) {
      amp_107 <- coefs_107["amp", "estimate"]
      acr_107 <- coefs_107["acr", "estimate"]
      intercept_107 <- coefs_107["(Intercept)", "estimate"]
    } else if (is.vector(coefs_107)) {
      amp_107 <- coefs_107["amp"]
      acr_107 <- coefs_107["acr"]
      intercept_107 <- coefs_107["(Intercept)"]
    } else {
      current_start_107 <- current_start_107 + step_size
      next
    }
    
    # Raw acrophase in hours
    acrophase_raw_107 <- (acr_107 * 24) / (2 * pi)
    acrophase_norm_107 <- (acrophase_raw_107 + 24) %% 24
    
    # Max and min time depending on amplitude sign
    if (amp_107 >= 0) {
      max_time_107 <- acrophase_norm_107
      min_time_107 <- (acrophase_norm_107 + 12) %% 24
    } else {
      min_time_107 <- acrophase_norm_107
      max_time_107 <- (acrophase_norm_107 + 12) %% 24
    }
    
    # Ensure max > 12 and min < 12 (if desired visual convention)
    if (max_time_107 < 12) {
      temp_107 <- max_time_107
      max_time_107 <- min_time_107
      min_time_107 <- temp_107
    }
    
    # Store results
    moving_window_107 <- rbind(moving_window_107, data.frame(
      Window_Start = current_start_107,
      Amp = amp_107,
      Acrophase_Rad = acr_107,
      Acrophase_Raw = acrophase_raw_107,
      Acrophase_Raw_Hours = acrophase_norm_107,
      Max_Time_Hours = max_time_107,
      Min_Time_Hours = min_time_107,
      Intercept = intercept_107
    ))
  }
  
  # Move to next window
  current_start_107 <- current_start_107 + step_size
}
```
**Description:** Moving Window Cos for 107: Plot
```{r}
ggplot(moving_window_107, aes(x = Window_Start)) +
  geom_line(aes(y = Max_Time_Hours, color = "Maximum"), size = 0.5) +
  geom_line(aes(y = Min_Time_Hours, color = "Minimum"), size = 0.5) +
  geom_point(aes(y = Max_Time_Hours, color = "Maximum"), size = 1) +
  geom_point(aes(y = Min_Time_Hours, color = "Minimum"), size = 1) +
  scale_color_manual(
    name = "Time Point",
    values = c("Maximum" = "red", "Minimum" = "blue")
  ) +
  scale_y_continuous(
    breaks = seq(0, 24, 2),
    limits = c(0, 24),
    expand = c(0, 0)
  ) +
  labs(
    title = "Diurnal Timing of Maximum and Minimum (Glucose Cosinor)",
    x = "Window Start Time",
    y = "Time of Day (Hours)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```
**Description:** Moving Window Cos for 108
```{r}
# Empty dataframe to store results
moving_window_108 <- data.frame(
  Window_Start = as.POSIXct(character()),
  Amp = numeric(),
  Acrophase_Rad = numeric(),
  Acrophase_Raw = numeric(),
  Acrophase_Raw_Hours = numeric(),
  Max_Time_Hours = numeric(),
  Min_Time_Hours = numeric(),
  Intercept = numeric(),
  stringsAsFactors = FALSE
)

# Define time boundaries
start_time_mv_108 <- min(glucose_fit_108_data$datetime)
end_time_mv_108 <- max(glucose_fit_108_data$datetime)

# Window and step sizes
window_length <- days(3)
step_size <- days(1)
current_start_108 <- start_time_mv_108

# Sliding window analysis
while (current_start_108 + window_length <= end_time_mv_108) {
  
  current_end_108 <- current_start_108 + window_length
  
  # Filter data within window
  window_data_108 <- glucose_fit_108_data %>%
    filter(datetime >= current_start_108 & datetime < current_end_108)
  
  # Skip windows with too few data points
  if (nrow(window_data_108) < 400) {
    current_start_108 <- current_start_108 + step_size
    next
  }
  
  # Fit cosinor model
  fit_108 <- tryCatch({
    cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = window_data_108, period = 24)
  }, error = function(e) NA)
  
  if (inherits(fit_108, "cosinor.lm")) {
    
    coefs_108 <- coef(fit_108, transformed = TRUE)
    
    # Extract coefficients
    if (is.matrix(coefs_108)) {
      amp_108 <- coefs_108["amp", "estimate"]
      acr_108 <- coefs_108["acr", "estimate"]
      intercept_108 <- coefs_108["(Intercept)", "estimate"]
    } else if (is.vector(coefs_108)) {
      amp_108 <- coefs_108["amp"]
      acr_108 <- coefs_108["acr"]
      intercept_108 <- coefs_108["(Intercept)"]
    } else {
      current_start_108 <- current_start_108 + step_size
      next
    }
    
    # Raw acrophase in hours
    acrophase_raw_108 <- (acr_108 * 24) / (2 * pi)
    acrophase_norm_108 <- (acrophase_raw_108 + 24) %% 24
    
    # Max and min time depending on amplitude sign
    if (amp_108 >= 0) {
      max_time_108 <- acrophase_norm_108
      min_time_108 <- (acrophase_norm_108 + 12) %% 24
    } else {
      min_time_108 <- acrophase_norm_108
      max_time_108 <- (acrophase_norm_108 + 12) %% 24
    }
    
    # Ensure max > 12 and min < 12 (if desired visual convention)
    if (max_time_108 < 12) {
      temp_108 <- max_time_108
      max_time_108 <- min_time_108
      min_time_108 <- temp_108
    }
    
    # Store results
    moving_window_108 <- rbind(moving_window_108, data.frame(
      Window_Start = current_start_108,
      Amp = amp_108,
      Acrophase_Rad = acr_108,
      Acrophase_Raw = acrophase_raw_108,
      Acrophase_Raw_Hours = acrophase_norm_108,
      Max_Time_Hours = max_time_108,
      Min_Time_Hours = min_time_108,
      Intercept = intercept_108
    ))
  }
  
  # Move to next window
  current_start_108 <- current_start_108 + step_size
}
```
**Description:** Moving Window Cos for 108: Plot
```{r}
ggplot(moving_window_108, aes(x = Window_Start)) +
  geom_line(aes(y = Max_Time_Hours, color = "Maximum"), size = 0.5) +
  geom_line(aes(y = Min_Time_Hours, color = "Minimum"), size = 0.5) +
  geom_point(aes(y = Max_Time_Hours, color = "Maximum"), size = 1) +
  geom_point(aes(y = Min_Time_Hours, color = "Minimum"), size = 1) +
  scale_color_manual(
    name = "Time Point",
    values = c("Maximum" = "red", "Minimum" = "blue")
  ) +
  scale_y_continuous(
    breaks = seq(0, 24, 2),
    limits = c(0, 24),
    expand = c(0, 0)
  ) +
  labs(
    title = "Diurnal Timing of Maximum and Minimum (Glucose Cosinor)",
    x = "Window Start Time",
    y = "Time of Day (Hours)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```
**Description:** Moving Window Cos for 109
```{r}
# Empty dataframe to store results
moving_window_109 <- data.frame(
  Window_Start = as.POSIXct(character()),
  Amp = numeric(),
  Acrophase_Rad = numeric(),
  Acrophase_Raw = numeric(),
  Acrophase_Raw_Hours = numeric(),
  Max_Time_Hours = numeric(),
  Min_Time_Hours = numeric(),
  Intercept = numeric(),
  stringsAsFactors = FALSE
)

# Define time boundaries
start_time_mv_109 <- min(glucose_fit_109_data$datetime)
end_time_mv_109 <- max(glucose_fit_109_data$datetime)

# Window and step sizes
window_length <- days(3)
step_size <- days(1)
current_start_109 <- start_time_mv_109

# Sliding window analysis
while (current_start_109 + window_length <= end_time_mv_109) {
  
  current_end_109 <- current_start_109 + window_length
  
  # Filter data within window
  window_data_109 <- glucose_fit_109_data %>%
    filter(datetime >= current_start_109 & datetime < current_end_109)
  
  # Skip windows with too few data points
  if (nrow(window_data_109) < 400) {
    current_start_109 <- current_start_109 + step_size
    next
  }
  
  # Fit cosinor model
  fit_109 <- tryCatch({
    cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = window_data_109, period = 24)
  }, error = function(e) NA)
  
  if (inherits(fit_109, "cosinor.lm")) {
    
    coefs_109 <- coef(fit_109, transformed = TRUE)
    
    # Extract coefficients
    if (is.matrix(coefs_109)) {
      amp_109 <- coefs_109["amp", "estimate"]
      acr_109 <- coefs_109["acr", "estimate"]
      intercept_109 <- coefs_109["(Intercept)", "estimate"]
    } else if (is.vector(coefs_109)) {
      amp_109 <- coefs_109["amp"]
      acr_109 <- coefs_109["acr"]
      intercept_109 <- coefs_109["(Intercept)"]
    } else {
      current_start_109 <- current_start_109 + step_size
      next
    }
    
    # Raw acrophase in hours
    acrophase_raw_109 <- (acr_109 * 24) / (2 * pi)
    acrophase_norm_109 <- (acrophase_raw_109 + 24) %% 24
    
    # Max and min time depending on amplitude sign
    if (amp_109 >= 0) {
      max_time_109 <- acrophase_norm_109
      min_time_109 <- (acrophase_norm_109 + 12) %% 24
    } else {
      min_time_109 <- acrophase_norm_109
      max_time_109 <- (acrophase_norm_109 + 12) %% 24
    }
    
    # Ensure max > 12 and min < 12 (if desired visual convention)
    if (max_time_109 < 12) {
      temp_109 <- max_time_109
      max_time_109 <- min_time_109
      min_time_109 <- temp_109
    }
    
    # Store results
    moving_window_109 <- rbind(moving_window_109, data.frame(
      Window_Start = current_start_109,
      Amp = amp_109,
      Acrophase_Rad = acr_109,
      Acrophase_Raw = acrophase_raw_109,
      Acrophase_Raw_Hours = acrophase_norm_109,
      Max_Time_Hours = max_time_109,
      Min_Time_Hours = min_time_109,
      Intercept = intercept_109
    ))
  }
  
  # Move to next window
  current_start_109 <- current_start_109 + step_size
}
```
**Description:** Moving Window Cos for 109: Plot
```{r}
ggplot(moving_window_109, aes(x = Window_Start)) +
  geom_line(aes(y = Max_Time_Hours, color = "Maximum"), size = 0.5) +
  geom_line(aes(y = Min_Time_Hours, color = "Minimum"), size = 0.5) +
  geom_point(aes(y = Max_Time_Hours, color = "Maximum"), size = 1) +
  geom_point(aes(y = Min_Time_Hours, color = "Minimum"), size = 1) +
  scale_color_manual(
    name = "Time Point",
    values = c("Maximum" = "red", "Minimum" = "blue")
  ) +
  scale_y_continuous(
    breaks = seq(0, 24, 2),
    limits = c(0, 24),
    expand = c(0, 0)
  ) +
  labs(
    title = "Diurnal Timing of Maximum and Minimum (Glucose Cosinor)",
    x = "Window Start Time",
    y = "Time of Day (Hours)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```
**Description:** Moving Window Cos for 112
```{r}
# Empty dataframe to store results
moving_window_112 <- data.frame(
  Window_Start = as.POSIXct(character()),
  Amp = numeric(),
  Acrophase_Rad = numeric(),
  Acrophase_Raw = numeric(),
  Acrophase_Raw_Hours = numeric(),
  Max_Time_Hours = numeric(),
  Min_Time_Hours = numeric(),
  Intercept = numeric(),
  stringsAsFactors = FALSE
)

# Define time boundaries
start_time_mv_112 <- min(glucose_fit_112_data$datetime)
end_time_mv_112 <- max(glucose_fit_112_data$datetime)

# Window and step sizes
window_length <- days(3)
step_size <- days(1)
current_start_112 <- start_time_mv_112

# Sliding window analysis
while (current_start_112 + window_length <= end_time_mv_112) {
  
  current_end_112 <- current_start_112 + window_length
  
  # Filter data within window
  window_data_112 <- glucose_fit_112_data %>%
    filter(datetime >= current_start_112 & datetime < current_end_112)
  
  # Skip windows with too few data points
  if (nrow(window_data_112) < 400) {
    current_start_112 <- current_start_112 + step_size
    next
  }
  
  # Fit cosinor model
  fit_112 <- tryCatch({
    cosinor.lm(`Glucose (mg/dl)` ~ time(dec.time), data = window_data_112, period = 24)
  }, error = function(e) NA)
  
  if (inherits(fit_112, "cosinor.lm")) {
    
    coefs_112 <- coef(fit_112, transformed = TRUE)
    
    # Extract coefficients
    if (is.matrix(coefs_112)) {
      amp_112 <- coefs_112["amp", "estimate"]
      acr_112 <- coefs_112["acr", "estimate"]
      intercept_112 <- coefs_112["(Intercept)", "estimate"]
    } else if (is.vector(coefs_112)) {
      amp_112 <- coefs_112["amp"]
      acr_112 <- coefs_112["acr"]
      intercept_112 <- coefs_112["(Intercept)"]
    } else {
      current_start_112 <- current_start_112 + step_size
      next
    }
    
    # Raw acrophase in hours
    acrophase_raw_112 <- (acr_112 * 24) / (2 * pi)
    acrophase_norm_112 <- (acrophase_raw_112 + 24) %% 24
    
    # Max and min time depending on amplitude sign
    if (amp_112 >= 0) {
      max_time_112 <- acrophase_norm_112
      min_time_112 <- (acrophase_norm_112 + 12) %% 24
    } else {
      min_time_112 <- acrophase_norm_112
      max_time_112 <- (acrophase_norm_112 + 12) %% 24
    }
    
    # Ensure max > 12 and min < 12 (if desired visual convention)
    if (max_time_112 < 12) {
      temp_112 <- max_time_112
      max_time_112 <- min_time_112
      min_time_112 <- temp_112
    }
    
    # Store results
    moving_window_112 <- rbind(moving_window_112, data.frame(
      Window_Start = current_start_112,
      Amp = amp_112,
      Acrophase_Rad = acr_112,
      Acrophase_Raw = acrophase_raw_112,
      Acrophase_Raw_Hours = acrophase_norm_112,
      Max_Time_Hours = max_time_112,
      Min_Time_Hours = min_time_112,
      Intercept = intercept_112
    ))
  }
  
  # Move to next window
  current_start_112 <- current_start_112 + step_size
}
```
**Description:** Moving Window Cos for 112: Plot
```{r}
ggplot(moving_window_112, aes(x = Window_Start)) +
  geom_line(aes(y = Max_Time_Hours, color = "Maximum"), size = 0.5) +
  geom_line(aes(y = Min_Time_Hours, color = "Minimum"), size = 0.5) +
  geom_point(aes(y = Max_Time_Hours, color = "Maximum"), size = 1) +
  geom_point(aes(y = Min_Time_Hours, color = "Minimum"), size = 1) +
  scale_color_manual(
    name = "Time Point",
    values = c("Maximum" = "red", "Minimum" = "blue")
  ) +
  scale_y_continuous(
    breaks = seq(0, 24, 2),
    limits = c(0, 24),
    expand = c(0, 0)
  ) +
  labs(
    title = "Diurnal Timing of Maximum and Minimum (Glucose Cosinor)",
    x = "Window Start Time",
    y = "Time of Day (Hours)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```
#### Moving Window with lm()
```{r}
library(dplyr)
library(lubridate)

# Leere Liste für alle IDs
all_results <- list()

# Alle IDs extrahieren
ids <- unique(glucose_fit_data$ID)

# Fenster-Parameter
window_length <- days(3)
step_size <- days(1)

# Schleife über alle IDs
for (id in ids) {
  
  # Daten für aktuelle ID
  glucose_id_data <- glucose_fit_data %>%
    filter(ID == id)
  
  # Prüfe, ob genug Daten da sind
  if (nrow(glucose_id_data) < 400) next
  
  # Zeitgrenzen
  start_time <- min(glucose_id_data$datetime)
  end_time   <- max(glucose_id_data$datetime)
  
  # Starte Sliding Window
  current_start <- start_time
  id_results <- list()  # Zwischenspeicher pro ID
  
  while (current_start + window_length <= end_time) {
    
    current_end <- current_start + window_length
    
    # Daten im Fenster
    window_data <- glucose_id_data %>%
      filter(datetime >= current_start & datetime < current_end)
    
    # Skip bei zu wenigen Datenpunkten
    if (nrow(window_data) < 400) {
      current_start <- current_start + step_size
      next
    }
    
    # Calculate cosine components
    dec_time <- window_data$dec.time
    window_data$cos_part <- cos(2 * pi * dec_time / 24)
    window_data$sin_part <- sin(2 * pi * dec_time / 24)
    
    # Cosinor-Fit
    fit <- tryCatch({
      lm(`Glucose (mg/dl)` ~ cos_part + sin_part, data = window_data)
    }, error = function(e) NA)
    
    # Falls Fit nicht funktioniert
    if (!inherits(fit, "lm")) {
      current_start <- current_start + step_size
      next
    }
    
    coefs <- coef(fit)
    
    # Falls NA in Koeffizienten
    if (any(is.na(coefs[c("(Intercept)", "cos_part", "sin_part")]))) {
      current_start <- current_start + step_size
      next
    }
    
    # Extrahiere Parameter
    intercept <- coefs["(Intercept)"]
    beta      <- coefs["cos_part"]
    gamma     <- coefs["sin_part"]
    
    amp <- sqrt(beta^2 + gamma^2)
    acr_rad <- atan2(gamma, beta)
    acrophase_raw <- (acr_rad * 24) / (2 * pi)
    acrophase_norm <- (acrophase_raw + 24) %% 24
    max_time <- acrophase_norm
    min_time <- (acrophase_norm + 12) %% 24
    
    # Ergebnisse speichern
    id_results[[length(id_results) + 1]] <- data.frame(
      ID = id,
      Window_Start = current_start,
      Amp = amp,
      Acrophase_Rad = acr_rad,
      Acrophase_Raw = acrophase_raw,
      Acrophase_Raw_Hours = acrophase_norm,
      Max_Time_Hours = max_time,
      Min_Time_Hours = min_time,
      Intercept = intercept
    )
    
    # Nächstes Fenster
    current_start <- current_start + step_size
  }
  
  # Ergebnisse der aktuellen ID speichern
  if (length(id_results) > 0) {
    all_results[[length(all_results) + 1]] <- do.call(rbind, id_results)
  }
}

# Kombiniere alle Ergebnisse in ein DataFrame
moving_window_all_ids <- do.call(rbind, all_results)

# Optional: Ergebnisse ansehen
head(moving_window_all_ids)
```
## Seasonal Analysis
**Description:** Define Seasons
```{r}
  
seasons <- function(date) {
    m <- as.numeric(format(date, "%m"))
    if (m %in% c(9, 10, 11)) {
      return("Autumn")
    } else if (m %in% c(3, 4, 5)) {
      return("Spring")
    } else if (m %in% c(6, 7, 8)) {
      return("Summer")
    } else {
      return("Winter")
    }
  }
```
**Description:** Add Seasons to Moving Window Data Frame
```{r}
moving_window_all_ids <- moving_window_all_ids %>%
  mutate(Season = sapply(Window_Start, seasons))
```
#### Acrophase: Linear Mixed Effects Model
**Description:** Install and Load Packages 
```{r}
  library(lme4)
  library(lmerTest)
```
**Description:** Apply Linear Mixed Effects Model
```{r}
# Set winter as reference level
moving_window_all_ids$Season <- relevel(factor(moving_window_all_ids$Season), ref = "Winter")
``` 

```{r}
# Fit the model
model_acr_season <- lmer(Acrophase_Raw_Hours ~ Season + (1 | ID), data = moving_window_all_ids)

# Show results
summary(model_acr_season)

 ggplot(moving_window_all_ids, aes(x = Season, y = Acrophase_Raw_Hours)) +
    geom_boxplot(fill = "lightblue", alpha = 0.6) +
    theme_minimal() +
    labs(title = "Acrophase by Season",
         x = "Season",
         y = "Acrophase") +
    theme(plot.title = element_text(hjust = 0.5))
```
#### Amplitude: Linear Mixed Effects Model
```{r}
model_amp_season <- lmer(Amp ~ Season + (1 | ID), data = moving_window_all_ids)
summary(model_amp_season)

# Amplitude Boxplot
ggplot(moving_window_all_ids, aes(x = Season, y = Amp)) +
  geom_boxplot(fill = "lightgreen", alpha = 0.6) +
  theme_minimal() +
  labs(title = "Amplitude by Season",
       x = "Season",
       y = "Amplitude") +
  theme(plot.title = element_text(hjust = 0.5))

```
#### Intercept: Linear Mixed Effects Model
```{r}
model_intercept_season <- lmer(Intercept ~ Season + (1 | ID), data = moving_window_all_ids)
summary(model_intercept_season)

# Intercept Boxplot
ggplot(moving_window_all_ids, aes(x = Season, y = Intercept)) +
  geom_boxplot(fill = "orange", alpha = 0.6) +
  theme_minimal() +
  labs(title = "Intercept by Season",
       x = "Season",
       y = "Intercept") +
  theme(plot.title = element_text(hjust = 0.5))
```
### Seasonal Cosinus Fit: Raw Data (NOT NEEDED)
**Description:** Bind Data Sets
```{r}
  # IDs und zugehörige DataFrames
  id_list <- c(102, 104, 107, 108, 109, 112)
  
  # Liste der DataFrames in gleicher Reihenfolge (z. B. vorher erstellt)
  moving_window_list <- list(
    moving_window_102,
    moving_window_104,
    moving_window_107,
    moving_window_108,
    moving_window_109,
    moving_window_112
  )
  
  # Füge die ID zu jedem DataFrame hinzu
  moving_window_data <- Map(function(df, id) {
    df$ID <- id
    return(df)
  }, moving_window_list, id_list)
  
  # Binde alles zusammen
  moving_window_data <- bind_rows(moving_window_data)
```

### Polar Plots 
#### Polar Plot for Acrophase for all IDs
```{r}
# Rad-Winkel berechnen
  moving_window_all_ids <- moving_window_all_ids %>%
    mutate(Max_Rad = (Max_Time_Hours / 24) * 2 * pi)
  
  # Initialize Data Frames for Pointer and SD-Rectangles
  all_pointers <- data.frame()
  all_rects <- data.frame()
  
  # Loop for all IDs
  for (id in id_list) {
    df_id <- moving_window_all_ids %>% filter(ID == id)
    
    avg_max <- mean(df_id$Max_Rad, na.rm = TRUE)
    sd_max <- sd(df_id$Max_Rad, na.rm = TRUE)
    
    rect_ymin <- 1 - 0.05 * (which(id_list == id))  
    rect_ymax <- rect_ymin + 0.05
    
    all_pointers <- bind_rows(all_pointers, data.frame(
      angle = avg_max,
      label = paste0("Avg Max ", id)
    ))
    
    all_rects <- bind_rows(all_rects, data.frame(
      xmin = avg_max - sd_max,
      xmax = avg_max + sd_max,
      ymin = rect_ymin,
      ymax = rect_ymax,
      label = paste0("Avg Max ", id)
    ))
  }
  
 # Add IDs to data frames 
  library(stringr)
  
  all_pointers <- all_pointers %>%
    mutate(ID = str_extract(label, "\\d+"))
  
  all_rects <- all_rects %>%
    mutate(ID = str_extract(label, "\\d+"))
  
  
  # Plot
  ggplot() +
    geom_rect(data = all_rects,
              aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = ID),
              alpha = 0.3) +
    geom_segment(data = all_pointers,
                 aes(x = angle, xend = angle, y = 0, yend = 1, color = ID),
                 linewidth = 0.6) +
    coord_polar(start = 0) +
    scale_x_continuous(
    breaks = seq(0, 2 * pi * 23/24, length.out = 24),
    labels = 0:23,
    limits = c(0, 2 * pi)) +
    scale_y_continuous(limits = c(0, 1), labels = NULL) +
    labs(
      title = "Acrophase + SD for all IDs",
      x = "Time of Day",
      y = NULL,
      color = "Pointer",
      fill = "Standard Deviation"
    ) +
    theme_minimal() +
    theme(
      axis.title.y = element_blank(),
      panel.grid.major = element_line(color = "grey80"),
      panel.grid.minor = element_blank(),
      legend.position = "bottom"
    )
```
#### Polar Plot of all IDs with Seasons
```{r}
library(dplyr)
library(ggplot2)

  # --- Feste Reihenfolge der IDs für Farben & vertikale Platzierung ---
id_list <- sort(unique(moving_window_all_ids$ID))

# --- Zusammenfassung: Durchschnitt & SD des Maxima pro Season & ID ---
season_summary <- moving_window_all_ids %>%
  group_by(ID, Season) %>%
  summarise(
    avg_max_rad = mean((Max_Time_Hours / 24) * 2 * pi, na.rm = TRUE),
    sd_max_rad = sd((Max_Time_Hours / 24) * 2 * pi, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    angle = avg_max_rad,
    xmin = avg_max_rad - sd_max_rad,
    xmax = avg_max_rad + sd_max_rad,
    ID = factor(ID, levels = id_list),
    # dynamische vertikale Positionen, um Überlappung zu vermeiden
    rect_ymin = 0.95 - 0.05 * (as.numeric(ID) - 1),
    rect_ymax = rect_ymin + 0.05
  )

# --- Zeiger-Daten extrahieren ---
pointers_seasons <- season_summary %>%
  select(ID, Season, angle)

# --- Rechteck-Daten extrahieren ---
rects_seasons <- season_summary %>%
  select(ID, Season, xmin, xmax, rect_ymin, rect_ymax)

# --- Plot erstellen ---
ggplot() +
  geom_rect(data = rects_seasons,
            aes(xmin = xmin, xmax = xmax, ymin = rect_ymin, ymax = rect_ymax, fill = ID),
            alpha = 0.3, color = NA) +
  geom_segment(data = pointers_seasons,
               aes(x = angle, xend = angle, y = 0, yend = 1, color = ID),
               linewidth = 0.6) +
  coord_polar(start = 0) +
  scale_x_continuous(
    breaks = seq(0, 2 * pi * 23/24, length.out = 24),
    labels = 0:23,
    limits = c(0, 2 * pi)
  ) +
  scale_y_continuous(limits = c(0, 1.05), labels = NULL) +
  labs(
    title = "Acrophase + SD per Season",
    x = "Time of Day",
    y = NULL,
    color = "ID",
    fill = "ID"
  ) +
  facet_wrap(~Season) +
  theme_minimal() +
  theme(
    axis.title.y = element_blank(),
    panel.grid.major = element_line(color = "grey80"),
    panel.grid.minor = element_blank(),
    legend.position = "bottom"
  )
```
## Photoperiod Analysis
```{r}
if (!requireNamespace("LightLogR", quietly = TRUE)) {
  install.packages("LightLogR")
}
```

```{r}
library(LightLogR)
```
**Description:** Add photoperiod to dataset
```{r}
coords <- c(52.52, 13.405)  # coords for Berlin
tz <- "Europe/Berlin"

# Suppose your dataset is `moving_window_all_ids` with a POSIXct column "Window_Start"
photoperiod_df <- photoperiod(
  coordinates = coords,
  dates = unique(as.Date(moving_window_all_ids$Window_Start)),
  tz = tz,
  solarDep = 0  # solarDep = 0 for true sunrise/sunset
)

# Join photoperiod info (dawn, dusk) back to  main dataset
moving_window_all_ids <- moving_window_all_ids %>%
  mutate(date = as.Date(Window_Start)) %>%
  left_join(photoperiod_df, by = c("date" = "date"))

# Add photoperiod state (day/night) for each timestamp
moving_window_all_ids <- add_photoperiod(
  moving_window_all_ids,
  coordinates = coords,
  Datetime.colname = Window_Start,
  solarDep = 0,
  overwrite = TRUE
)

moving_window_all_ids <- moving_window_all_ids %>%
  mutate(photoperiod_hours = as.numeric(photoperiod, units = "hours"))
```
### Acrophase: Linear Mixed Model
**Description:** Linear Mixed Model
```{r}
library(lme4)

model_photoperiod_acr <- lmer(
  Acrophase_Raw_Hours ~ photoperiod_hours + (1 | ID),
  data = moving_window_all_ids
)

summary(model_photoperiod_acr)
``` 
**Description:** Create a Graph
```{r}
library(ggeffects)

# Get predictions
pred_phot_acr <- ggpredict(model_photoperiod_acr, terms = "photoperiod_hours")

# Plot
ggplot(moving_window_all_ids, aes(x = photoperiod_hours, y = Acrophase_Raw_Hours)) +
  geom_point(alpha = 0.4, color = "blue") +
  geom_line(data = pred_phot_acr, aes(x = x, y = predicted), color = "red", size = 1) +
  geom_ribbon(data = pred_phot_acr, aes(x = x, ymin = conf.low, ymax = conf.high),
              inherit.aes = FALSE, fill = "pink", alpha = 0.3) +
  theme_minimal() +
  labs(
    title = "Acrophase vs. Photoperiod (LME fit)",
    x = "Photoperiod (hours)",
    y = "Acrophase (hours since midnight)"
  ) +
  theme(plot.title = element_text(hjust = 0.5))
```
**Description:** Create this graph but with models for every ID
```{r}
# Get fitted values for each ID
id_fits_phot_acr <- moving_window_all_ids %>%
  group_by(ID) %>%
  do({
    model_id <- lm(Acrophase_Raw_Hours ~ photoperiod_hours, data = .)
    data.frame(
      photoperiod_hours = seq(min(.$photoperiod_hours), max(.$photoperiod_hours), length.out = 100),
      Acrophase_pred = predict(model_id, newdata = data.frame(
        photoperiod_hours = seq(min(.$photoperiod_hours), max(.$photoperiod_hours), length.out = 100)
      )),
      ID = unique(.$ID)
    )
  })

# Plot
ggplot(moving_window_all_ids, aes(x = photoperiod_hours, y = Acrophase_Raw_Hours, color = ID)) +
  geom_point(alpha = 0.3) +
  geom_line(data = id_fits_phot_acr, aes(x = photoperiod_hours, y = Acrophase_pred, color = ID), size = 0.8) +
  geom_line(data = pred_phot_acr, aes(x = x, y = predicted), color = "black", size = 1.2, inherit.aes = FALSE) +
  geom_ribbon(data = pred_phot_acr, aes(x = x, ymin = conf.low, ymax = conf.high),
              inherit.aes = FALSE, fill = "grey70", alpha = 0.3) +
  theme_minimal() +
  labs(
    title = "Acrophase vs. Photoperiod per ID + Overall Trend",
    x = "Photoperiod (hours)",
    y = "Acrophase (hours since midnight)"
  ) +
  theme(plot.title = element_text(hjust = 0.5))
```
### Amplitude: Linear Mixed Model
```{r}
model_photoperiod_amp <- lmer(
  Amp ~ photoperiod_hours + (1 | ID),
  data = moving_window_all_ids
)

summary(model_photoperiod_amp)
```
**Description:** Plot
```{r}
# Per-ID fits
id_fits_amp <- moving_window_all_ids %>%
  group_by(ID) %>%
  do({
    model_id <- lm(Amp ~ photoperiod_hours, data = .)
    data.frame(
      photoperiod_hours = seq(min(.$photoperiod_hours), max(.$photoperiod_hours), length.out = 100),
      Amp_pred = predict(model_id, newdata = data.frame(
        photoperiod_hours = seq(min(.$photoperiod_hours), max(.$photoperiod_hours), length.out = 100)
      )),
      ID = unique(.$ID)
    )
  })

# Overall fit from the mixed model
pred_amp <- ggeffects::ggpredict(model_photoperiod_amp, terms = "photoperiod_hours")

# Plot
ggplot(moving_window_all_ids, aes(x = photoperiod_hours, y = Amp, color = ID)) +
  geom_point(alpha = 0.3) +
  geom_line(data = id_fits_amp, aes(x = photoperiod_hours, y = Amp_pred, color = ID), size = 0.8) +
  geom_line(data = pred_amp, aes(x = x, y = predicted), color = "black", size = 1.2, inherit.aes = FALSE) +
  geom_ribbon(data = pred_amp, aes(x = x, ymin = conf.low, ymax = conf.high),
              inherit.aes = FALSE, fill = "grey70", alpha = 0.3) +
  theme_minimal() +
  labs(
    title = "Amplitude vs. Photoperiod per ID + Overall Trend",
    x = "Photoperiod (hours)",
    y = "Amplitude"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

```
### Intercept: Linear Mixed Model
```{r}
model_photoperiod_int <- lmer(
  Intercept ~ photoperiod_hours + (1 | ID),
  data = moving_window_all_ids
)

summary(model_photoperiod_int)
```
**Description:** Plot
```{r}
# Per-ID fits
id_fits_int <- moving_window_all_ids %>%
  group_by(ID) %>%
  do({
    model_id <- lm(Intercept ~ photoperiod_hours, data = .)
    data.frame(
      photoperiod_hours = seq(min(.$photoperiod_hours), max(.$photoperiod_hours), length.out = 100),
      Intercept_pred = predict(model_id, newdata = data.frame(
        photoperiod_hours = seq(min(.$photoperiod_hours), max(.$photoperiod_hours), length.out = 100)
      )),
      ID = unique(.$ID)
    )
  })

# Overall fit from the mixed model
pred_int <- ggeffects::ggpredict(model_photoperiod_int, terms = "photoperiod_hours")

# Plot
ggplot(moving_window_all_ids, aes(x = photoperiod_hours, y = Intercept, color = ID)) +
  geom_point(alpha = 0.3) +
  geom_line(data = id_fits_int, aes(x = photoperiod_hours, y = Intercept_pred, color = ID), size = 0.8) +
  geom_line(data = pred_int, aes(x = x, y = predicted), color = "black", size = 1.2, inherit.aes = FALSE) +
  geom_ribbon(data = pred_int, aes(x = x, ymin = conf.low, ymax = conf.high),
              inherit.aes = FALSE, fill = "grey70", alpha = 0.3) +
  theme_minimal() +
  labs(
    title = "Intercept vs. Photoperiod per ID + Overall Trend",
    x = "Photoperiod (hours)",
    y = "Intercept"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

```